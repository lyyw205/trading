# 전략 커스터마이징 기획서

> 작성일: 2026-02-25
> 검토: Planner + Architect + Critic 3자 합의 (Consensus Planning)
> 대상: crypto-multi-trader (단일 서버, <20 계정)

---

## 1. 배경 및 목적

현재 시스템은 `lot_stacking`과 `trend_buy` 두 가지 전략만 존재하며,
모든 전략이 모든 계정에 동일하게 노출된다. 전략 가시성/범위 개념이 전혀 없다.

앞으로 전략을 추가할 예정이므로, 다음 두 가지 유형을 구분할 수 있어야 한다:

- **공용 전략(Public)**: 모든 계정 대시보드에서 보이고, 사용자가 직접 on/off 가능
- **커스텀 전략(Custom)**: 관리자가 등록한 특정 계정의 대시보드에만 보이고, 해당 계정에서만 on/off 가능

---

## 2. 현재 구조 진단

### 2.1 전략 등록 (코드 레벨)

전략은 `@StrategyRegistry.register` 데코레이터로 import 시점에 인메모리 등록된다.

```python
# app/strategies/registry.py
class StrategyRegistry:
    _strategies: dict[str, type[BaseStrategy]] = {}

    @classmethod
    def register(cls, strategy_class):
        cls._strategies[strategy_class.name] = strategy_class

    @classmethod
    def list_all(cls) -> list[dict]:
        # 모든 등록 전략을 무조건 반환 — 스코핑 없음
```

`BaseStrategy` 클래스 속성: `name`, `display_name`, `description`, `version`, `default_params`, `tunable_params`
→ **가시성/범위 관련 속성이 전혀 없음**

### 2.2 전략-계정 연결 (DB 레벨)

`strategy_configs` 테이블이 계정별 전략 설정을 관리한다:

```
strategy_configs
├── id (UUID PK)
├── account_id (FK → trading_accounts)
├── strategy_name (String)
├── is_enabled (Boolean, default true)
├── params (JSONB)
└── UniqueConstraint(account_id, strategy_name)
```

**핵심 사실: `strategy_configs` 행이 없으면 해당 계정에서 해당 전략은 실행되지 않는다.**
트레이딩 엔진(`account_trader.py:117-122`)이 `is_enabled=True`인 config 행만 로드하여 실행하기 때문이다.
이것은 이미 암묵적인 "접근 제어"로 작동하고 있다.

### 2.3 API

```
GET  /api/strategies                                → 모든 전략 반환 (스코핑 없음)
GET  /api/accounts/{id}/strategies                  → 계정의 strategy_configs 반환
PUT  /api/accounts/{id}/strategies/{name}           → 전략 파라미터 수정 (아무 전략이나 허용)
POST /api/accounts/{id}/strategies/{name}/enable    → 전략 활성화
POST /api/accounts/{id}/strategies/{name}/disable   → 전략 비활성화
```

### 2.4 대시보드 (하드코딩 문제)

`account_detail.html`의 Tune Controls 섹션이 완전히 하드코딩되어 있다:

- **Tune 패널**: LOT Stacking(8개 입력 필드) + TREND Buy(6개 입력 필드)가 HTML로 고정
- **필터 탭**: "All", "LOT Stacking", "TREND Buy" 3개가 하드코딩
- **JS 함수**: `loadTuneValues()`, `saveTuneValues()`가 `ls-drop-pct`, `tb-step-pct` 등 특정 DOM ID를 직접 참조
- **Admin 백테스트 UI**: `admin.html`에서도 전략 체크박스/파라미터가 하드코딩

→ **전략이 추가될 때마다 HTML/JS를 수동으로 수정해야 하는 구조**

---

## 3. 설계 결정 및 근거

### 3.1 핵심 설계: 새 테이블 없이 기존 구조 활용

**3자 검토 결과, `strategy_configs`를 "접근 제어 + 설정" 겸용 테이블로 활용하기로 결정했다.**

| 검토 항목 | 결정 | 근거 |
|-----------|------|------|
| `strategy_access` 별도 테이블 | **불필요** | `strategy_configs` 행 유무로 접근 제어 가능. 별도 테이블은 이중 관리 |
| `BaseStrategy`에 scope 속성 | `is_public: bool = True` 하나만 | 전략의 공용/커스텀 구분은 코드에서 정의되는 정적 속성. 복잡한 scope 문자열 불필요 |
| DB `strategy_registry` 테이블 | **불필요** | 인메모리 레지스트리 + 데코레이터 패턴이 단일 서버에 최적 |
| 대시보드 동적화 방식 | **파셜 템플릿 + Jinja2 조건부 include** | 풀 동적 폼 렌더링(JS 빌드)은 `tunable_params` 메타데이터 부족으로 불완전. 파셜이 디자인 유연성 유지에 최적 |

### 3.2 공용 vs 커스텀 전략 동작 방식

#### 공용 전략 (`is_public = True`)

예: `lot_stacking`, `trend_buy` (기존 전략)

```
대시보드 표시: 항상 (config 행 유무와 무관)
on/off 제어:  사용자가 직접 가능
config 행:    enable 시 자동 생성, disable 시 is_enabled=false
실행 조건:    strategy_configs에 행 존재 + is_enabled=True
```

- 모든 계정 대시보드에서 항상 보인다
- config 행이 없어도 "Off" 상태로 표시되고, 사용자가 Enable 하면 config 행이 생성된다
- 기존 동작과 100% 하위 호환

#### 커스텀 전략 (`is_public = False`)

예: 향후 추가될 특수 전략

```
대시보드 표시: config 행이 있는 계정에만 보임
on/off 제어:  할당된 계정에서만 가능
config 행:    관리자가 생성 (할당) / 삭제 (해제)
실행 조건:    strategy_configs에 행 존재 + is_enabled=True
```

- **관리자가 해당 계정에 `strategy_configs` 행을 생성해야 비로소 보인다**
- config 행이 없으면 대시보드에 아예 표시되지 않는다
- config 행이 있으면 사용자가 on/off 할 수 있다
- 관리자가 config 행을 삭제하면 해제 (클린업 포함)

#### 흐름 예시

```
[커스텀 전략 "grid_trading" 추가 시나리오]

1. 개발자: grid_trading.py 작성, is_public = False 선언
2. 관리자: Admin 페이지에서 "계정 A"에 grid_trading 할당
   → strategy_configs에 (account_A, grid_trading, is_enabled=false, {}) 행 생성
3. 계정 A 대시보드: grid_trading 튜닝 패널이 나타남 (Off 상태)
4. 사용자: grid_trading Enable 클릭 → is_enabled=true
5. 트레이딩 엔진: 다음 사이클에서 grid_trading.tick() 실행 시작
6. 계정 B 대시보드: grid_trading 패널이 보이지 않음 (config 행 없음)
```

---

## 4. 구현 계획 (4 Phase)

### Phase 1 — BaseStrategy 확장 + API 필터링 (0.5일)

> 위험도: 낮음 (기존 동작 변경 없음)

#### 무엇을 하는가

전략 클래스에 공용/커스텀 구분을 추가하고, API가 계정별로 사용 가능한 전략만 반환하도록 한다.

#### 1-A. BaseStrategy에 `is_public` 속성 추가

현재 `BaseStrategy`에는 전략의 가시성을 제어하는 속성이 없다.
`is_public: bool = True`를 추가하면:
- 기존 전략(`lot_stacking`, `trend_buy`)은 기본값 `True`라 변경 불필요
- 새 커스텀 전략 작성 시 `is_public = False`로 선언

```python
# app/strategies/base.py — 변경
class BaseStrategy(ABC):
    name: str = ""
    display_name: str = ""
    description: str = ""
    version: str = "1.0.0"
    is_public: bool = True          # ← 추가: 공용(True) / 커스텀(False)
    default_params: Dict[str, Any] = {}
    tunable_params: Dict[str, Dict[str, Any]] = {}
```

#### 1-B. StrategyRegistry에 `list_for_account()` 추가

현재 `list_all()`은 모든 전략을 무조건 반환한다.
계정별로 사용 가능한 전략만 반환하는 메서드를 추가한다:

```python
# app/strategies/registry.py — 추가
@classmethod
async def list_for_account(cls, account_id: UUID, session: AsyncSession) -> list[dict]:
    """해당 계정이 접근 가능한 전략 목록 반환.

    - is_public=True 전략: 항상 포함
    - is_public=False 전략: strategy_configs에 행이 있는 경우만 포함
    """
    # 이 계정에 config 행이 있는 전략 이름 조회
    stmt = select(StrategyConfig.strategy_name).where(
        StrategyConfig.account_id == account_id
    )
    result = await session.execute(stmt)
    assigned = {row for row in result.scalars().all()}

    strategies = []
    for name, strategy_cls in cls._strategies.items():
        instance = strategy_cls()
        if instance.is_public or name in assigned:
            strategies.append({
                "name": instance.name,
                "display_name": instance.display_name,
                "description": instance.description,
                "version": instance.version,
                "is_public": instance.is_public,
                "default_params": instance.default_params,
                "tunable_params": instance.tunable_params,
            })
    return strategies
```

#### 1-C. API 스코프 필터링

```
GET /api/accounts/{id}/available-strategies  → 신규: 계정별 사용 가능 전략 목록
```

기존 `GET /api/strategies`는 전략 카탈로그(전체 목록)로 유지하되,
대시보드와 프론트엔드는 새 엔드포인트를 사용한다.

전략 변경 API(`PUT`, `enable`, `disable`)에도 스코프 검증을 추가한다:
- 커스텀 전략에 대해 config 행이 없는 계정에서 호출 시 403 반환

#### 변경 파일 목록

| 파일 | 변경 내용 |
|------|-----------|
| `app/strategies/base.py` | `is_public: bool = True` 속성 추가 |
| `app/strategies/registry.py` | `list_for_account()` 메서드 추가, `list_all()`에 `is_public` 필드 포함 |
| `app/schemas/strategy.py` | `StrategyInfo`에 `is_public` 필드 추가 |
| `app/api/strategies.py` | `GET /api/accounts/{id}/available-strategies` 신규, 기존 변경 API에 스코프 검증 추가 |

#### 완료 기준

- [ ] `list_all()`에 `is_public` 필드 포함
- [ ] `list_for_account()`가 공용 전략은 항상 반환, 커스텀 전략은 config 행 존재 시에만 반환
- [ ] 커스텀 전략에 대해 미할당 계정에서 enable/disable/update 시 403 반환
- [ ] 기존 lot_stacking, trend_buy 동작 변경 없음

---

### Phase 2 — 대시보드 동적화 (1~1.5일)

> 위험도: 중간 (프론트엔드 전면 리팩토링)

#### 무엇을 하는가

하드코딩된 전략 UI를 동적으로 전환하여, 전략이 추가/제거될 때 HTML/JS를 수동 수정할 필요가 없게 한다.

#### 2-A. Tune 패널을 전략별 파셜 템플릿으로 분리

현재 `account_detail.html:70-148`에 LOT Stacking과 TREND Buy 폼이 하드코딩되어 있다.
이것을 전략별 파셜 템플릿으로 분리한다:

```
app/dashboard/templates/
├── account_detail.html          ← 수정: 하드코딩 패널 제거, Jinja2 동적 include
├── _tune_lot_stacking.html      ← 신규: LOT Stacking 전용 폼 파셜
├── _tune_trend_buy.html         ← 신규: TREND Buy 전용 폼 파셜
└── _tune_generic.html           ← 신규: tunable_params 기반 범용 폼 (커스텀 전략용)
```

**파셜 템플릿 방식을 선택한 이유:**
- 기존 전략의 UI 디자인을 100% 유지 가능 (각 파셜이 독자적 레이아웃)
- 새 전략 추가 시 파셜 하나만 추가하면 됨
- `tunable_params` 메타데이터가 UI 렌더링에 불완전한 문제를 회피
  (실제 대시보드 폼에 8개 필드가 있지만 `tunable_params`에는 5개만 정의됨)
- 커스텀 전략 중 전용 파셜이 없는 것은 `_tune_generic.html`로 자동 렌더링

#### 2-B. account_detail.html 동적 렌더링

`routes.py`에서 해당 계정의 사용 가능 전략 목록을 조회하여 템플릿 컨텍스트로 전달한다:

```python
# app/dashboard/routes.py — account_detail_page 수정
@router.get("/accounts/{account_id}", response_class=HTMLResponse)
async def account_detail_page(request, account_id, session=Depends(get_trading_session)):
    strategies = await StrategyRegistry.list_for_account(UUID(account_id), session)
    return templates.TemplateResponse("account_detail.html", {
        "request": request,
        "account_id": account_id,
        "strategies": strategies,   # ← 사용 가능한 전략 목록
    })
```

템플릿에서 조건부 include:

```html
<!-- account_detail.html — Tune Controls 섹션 -->
<div class="tune-panels">
  {% for strat in strategies %}
    {% set partial = "_tune_" + strat.name + ".html" %}
    {% if partial_exists(partial) %}
      {% include partial %}
    {% else %}
      {% include "_tune_generic.html" %}
    {% endif %}
  {% endfor %}
</div>
```

#### 2-C. 필터 탭 동적 생성

```html
<!-- 현재 하드코딩된 38-41줄 대체 -->
<div class="filter-tabs" id="lot-filter-tabs">
  <button class="filter-tab active" data-filter="all" onclick="filterLots('all')">All</button>
  {% for strat in strategies %}
  <button class="filter-tab" data-filter="{{ strat.name }}"
          onclick="filterLots('{{ strat.name }}')">{{ strat.display_name }}</button>
  {% endfor %}
</div>
```

#### 2-D. main.js 범용 tune 함수

하드코딩된 `loadTuneValues()`/`saveTuneValues()`를 `data-strategy` + `data-param` 속성 기반 범용 함수로 교체한다:

```javascript
// 모든 전략에 대해 범용으로 동작
async function loadDynamicTune(accountId) {
  const resp = await apiFetch('/api/dashboard/' + accountId + '/tune');
  if (!resp.ok) return;
  const configs = await resp.json();
  // data-strategy, data-param 속성으로 자동 매핑
  for (const [stratName, params] of Object.entries(configs)) {
    document.querySelectorAll(`.tune-input[data-strategy="${stratName}"]`).forEach(input => {
      const key = input.dataset.param;
      if (params[key] != null) input.value = params[key];
    });
  }
}

async function saveDynamicTune(accountId, strategyName) {
  const params = {};
  document.querySelectorAll(`.tune-input[data-strategy="${strategyName}"]`).forEach(input => {
    if (input.value !== '') {
      params[input.dataset.param] = input.type === 'number' ? parseFloat(input.value) : input.value;
    }
  });
  // API 호출...
}
```

파셜 템플릿의 입력 필드는 `data-strategy`와 `data-param` 속성을 가진다:

```html
<!-- _tune_lot_stacking.html 예시 -->
<div class="tune-panel" data-strategy="lot_stacking">
  <h3 class="tune-panel-title">LOT Stacking</h3>
  <div class="tune-grid">
    <div class="form-group">
      <label class="form-label">Drop %</label>
      <input type="number" step="0.01" class="form-input tune-input"
             data-strategy="lot_stacking" data-param="drop_pct">
    </div>
    <!-- ... 나머지 필드들 ... -->
  </div>
  <button class="btn btn-primary"
          onclick="saveDynamicTune('{{ account_id }}', 'lot_stacking')">Save</button>
</div>
```

#### 변경 파일 목록

| 파일 | 변경 내용 |
|------|-----------|
| `app/dashboard/routes.py` | `account_detail_page`에 전략 컨텍스트 전달 |
| `app/dashboard/templates/account_detail.html` | 하드코딩 tune 패널/필터 탭 → 동적 include |
| `app/dashboard/templates/_tune_lot_stacking.html` | 신규: LOT Stacking 파셜 |
| `app/dashboard/templates/_tune_trend_buy.html` | 신규: TREND Buy 파셜 |
| `app/dashboard/templates/_tune_generic.html` | 신규: tunable_params 기반 범용 파셜 |
| `app/dashboard/static/js/main.js` | 하드코딩 tune 함수 → 범용 `data-*` 기반 함수 |

#### 완료 기준

- [ ] 공용 전략: 모든 계정 대시보드에서 tune 패널 표시
- [ ] 커스텀 전략: 할당된 계정에서만 tune 패널 표시, 미할당 계정에서는 미표시
- [ ] 필터 탭이 사용 가능한 전략 기반으로 동적 생성
- [ ] 기존 LOT Stacking, TREND Buy 폼 UI/UX 변경 없음
- [ ] tune 값 로드/저장이 모든 전략에 대해 정상 동작

---

### Phase 3 — Admin 전략 배정 UI (0.5일)

> 위험도: 낮음

#### 무엇을 하는가

관리자가 Admin 페이지에서 커스텀 전략을 특정 계정에 할당/해제할 수 있는 UI를 추가한다.

#### 3-A. 전략 할당/해제 API

```
GET    /api/admin/strategy-assignments         → 전체 할당 현황 (커스텀 전략 기준)
POST   /api/admin/strategy-assignments         → 전략 할당 (strategy_configs 행 생성, is_enabled=false)
DELETE /api/admin/strategy-assignments/{id}     → 전략 해제 (strategy_configs 행 삭제 + 클린업)
```

**할당** = `strategy_configs`에 행 생성:

```python
# POST /api/admin/strategy-assignments
# body: { "account_id": "...", "strategy_name": "grid_trading" }

# 1. 커스텀 전략인지 확인
strategy_cls = StrategyRegistry.get(strategy_name)
if strategy_cls().is_public:
    raise HTTPException(400, "Public strategies don't need assignment")

# 2. strategy_configs 행 생성 (비활성 상태)
config = StrategyConfig(
    account_id=account_id,
    strategy_name=strategy_name,
    is_enabled=False,      # 할당만 — 활성화는 사용자가 대시보드에서
    params={},
)
session.add(config)
```

**해제** = `strategy_configs` 행 삭제 + 클린업 (Phase 4에서 상세):

```python
# DELETE /api/admin/strategy-assignments/{config_id}
# 1. OPEN 로트 확인 (있으면 삭제 거부)
# 2. strategy_state 클린업
# 3. strategy_configs 행 삭제
```

#### 3-B. Admin 페이지 UI

`admin.html`에 "Strategy Assignment" 섹션을 추가한다:

```
┌─────────────────────────────────────────────────────────┐
│  Strategy Assignment                                     │
│                                                          │
│  Custom Strategy: [grid_trading ▼]                       │
│  Account:         [Account A ▼]    [Assign]              │
│                                                          │
│  ┌──────────┬──────────────┬────────┬────────┐          │
│  │ Account  │ Strategy     │ Status │ Action │          │
│  ├──────────┼──────────────┼────────┼────────┤          │
│  │ Account A│ grid_trading │ Off    │ Remove │          │
│  │ Account C│ grid_trading │ On     │ Remove │          │
│  └──────────┴──────────────┴────────┴────────┘          │
└─────────────────────────────────────────────────────────┘
```

#### 변경 파일 목록

| 파일 | 변경 내용 |
|------|-----------|
| `app/api/admin.py` | 전략 할당/해제 엔드포인트 3개 추가 |
| `app/dashboard/templates/admin.html` | Strategy Assignment 섹션 추가 |
| `app/dashboard/static/js/main.js` | admin 전략 배정 관련 JS 함수 추가 |

#### 완료 기준

- [ ] 관리자가 Admin 페이지에서 커스텀 전략을 계정에 할당 가능
- [ ] 할당 시 strategy_configs 행 생성 (is_enabled=false)
- [ ] 해제 시 strategy_configs 행 삭제 + 클린업 수행
- [ ] 공용 전략에 대한 할당 시도 시 에러 반환

---

### Phase 4 — 안전장치 (0.5일)

> 위험도: 중간 (데이터 정합성 관련)

#### 무엇을 하는가

전략 해제 시 데이터 정합성을 보장하고, 트레이딩 엔진에 defense-in-depth를 추가한다.

#### 4-A. 전략 해제 시 OPEN 로트 가드

**문제:** 커스텀 전략이 생성한 OPEN 상태 로트가 있는 상태에서 전략을 해제하면:
- 거래소에 제출된 매도 주문이 여전히 살아 있을 수 있음
- 해당 로트의 익절/손절 관리가 중단됨

**해결:** 전략 해제(config 행 삭제) 전에 해당 전략의 OPEN 로트가 0건인지 확인한다.
OPEN 로트가 있으면 삭제를 거부하고, 먼저 포지션 정리를 요구한다.

```python
# 삭제 전 가드
open_lots = await lot_repo.get_open_lots(account_id, symbol, strategy_name)
if open_lots:
    raise HTTPException(400, f"Cannot remove: {len(open_lots)} open lots exist. Close positions first.")
```

#### 4-B. `strategy_state` 클린업

**문제:** 전략 제거 시 `strategy_state` 테이블에 해당 전략의 상태 키-값이 남는다.
특히 `pending_order_id` 같은 키가 남으면, 나중에 같은 전략을 재할당했을 때
**존재하지 않는 주문을 추적하려 시도**할 수 있다.

**해결:** 전략 해제 시 `strategy_state`에서 해당 scope의 행을 전부 삭제한다.

```python
# strategy_state 클린업
await session.execute(
    delete(StrategyState).where(
        StrategyState.account_id == account_id,
        StrategyState.scope == strategy_name,
    )
)
```

#### 4-C. 트레이딩 엔진 defense-in-depth

현재 트레이딩 엔진은 `strategy_configs`에서 `is_enabled=True`인 행만 로드하므로,
config 행이 없는 전략은 이미 실행되지 않는다.

그러나 명시적인 검증 + 경고 로그를 추가하여 안전장치를 강화한다:

```python
# app/services/account_trader.py — step() 내부, 전략 실행 전
for sc in strategy_configs:
    strategy_cls = StrategyRegistry.get(sc.strategy_name)
    if not strategy_cls().is_public:
        # 커스텀 전략: config 행 존재를 재확인 (defense-in-depth)
        logger.debug("[%s] Running custom strategy: %s", self.account_id, sc.strategy_name)

    strategy = self._get_or_create_strategy(sc.strategy_name)
    # ... 이하 동일
```

#### 4-D. `tunable_params` 보완

현재 대시보드 폼에 있지만 `tunable_params`에 누락된 파라미터가 있다:
- `lot_stacking`: `buy_usdt`, `prebuy_pct`, `cancel_rebound_pct` 등이 `tunable_params`에 없을 수 있음
- 범용 폼(`_tune_generic.html`)이 정확히 동작하려면 `tunable_params`가 완전해야 함

각 전략의 `tunable_params`를 검토하여 누락된 파라미터를 보완한다.

#### 변경 파일 목록

| 파일 | 변경 내용 |
|------|-----------|
| `app/api/admin.py` | 전략 해제 시 OPEN 로트 가드 + state 클린업 |
| `app/services/account_trader.py` | 커스텀 전략 실행 시 로그 추가 |
| `app/strategies/lot_stacking.py` | `tunable_params` 누락 항목 보완 |
| `app/strategies/trend_buy.py` | `tunable_params` 누락 항목 보완 |

#### 완료 기준

- [ ] OPEN 로트가 있는 전략 해제 시 400 에러 반환 ("포지션 먼저 정리 필요")
- [ ] 전략 해제 시 strategy_state의 관련 행이 삭제됨
- [ ] 재할당 시 깨끗한 상태에서 시작 (고아 데이터 없음)
- [ ] `tunable_params`가 대시보드 폼의 모든 필드를 포함

---

## 5. 제외 항목 및 근거

| 항목 | 이유 |
|------|------|
| `strategy_access` 별도 테이블 | `strategy_configs` 행 유무가 이미 접근 제어 역할. 별도 테이블은 이중 관리를 유발 |
| DB `strategy_registry` 테이블 | 전략 실행 코드가 Python 클래스이므로, DB에 메타데이터를 넣으면 이중 관리. 인메모리 레지스트리가 단일 서버에 최적 |
| 풀 동적 폼 렌더링 (JS 메타데이터 빌드) | `tunable_params`에 UI 렌더링 정보 부족(필드 순서, 그룹핑, select/input 구분 등). 파셜 템플릿이 디자인 유연성 유지에 최적 |
| 백테스트 수정 | 백테스트 러너는 `strategy_names` 파라미터를 직접 받으므로 DB 기반 스코핑의 영향 없음 |

---

## 6. DB 마이그레이션

**마이그레이션 불필요.** 새 테이블이나 컬럼 추가가 없다.

- `strategy_configs` 테이블: 변경 없음 (기존 구조 그대로 활용)
- `BaseStrategy.is_public`: 코드 레벨 속성이므로 DB 변경 불필요
- 기존 `lot_stacking`/`trend_buy`의 strategy_configs 행: 변경 불필요 (is_public=True가 기본값이므로 그대로 동작)

---

## 7. 총 예상 공수

| Phase | 내용 | 공수 | 위험도 |
|-------|------|------|--------|
| Phase 1 | BaseStrategy 확장 + API 필터링 | 0.5일 | 낮음 |
| Phase 2 | 대시보드 동적화 (파셜 + 범용 JS) | 1~1.5일 | 중간 |
| Phase 3 | Admin 전략 배정 UI | 0.5일 | 낮음 |
| Phase 4 | 안전장치 (로트 가드 + state 클린업) | 0.5일 | 중간 |
| **합계** | | **2.5~3일** | |

---

## 8. 구현 시 주의사항

### Phase 2 주의사항 (대시보드)

- **기존 UI 회귀 방지**: 파셜 분리 후 LOT Stacking / TREND Buy 폼이 기존과 동일하게 동작하는지 반드시 확인
- **`_tune_generic.html` 한계**: `tunable_params`에 boolean(`recenter_enabled`)이나 select 타입이 있으면 `<input type="number">`로는 부족. `tunable_params`에 `type: "bool"`, `type: "select"` 등을 추가하거나, 전용 파셜을 만들어야 함
- **CSS 영향**: 기존 `.tune-panel`, `.tune-grid` 클래스 구조를 파셜에서도 동일하게 유지해야 레이아웃 깨지지 않음

### Phase 3 주의사항 (Admin)

- **공용 전략 할당 시도 방어**: 공용 전략은 모든 계정에 이미 사용 가능하므로, 할당 API 호출 시 "Public strategies don't need assignment" 에러를 반환해야 함
- **중복 할당 방어**: `(account_id, strategy_name)` 유니크 제약이 이미 있으므로 DB 레벨에서 방어됨, API에서도 명시적 에러 메시지 반환

### Phase 4 주의사항 (안전장치)

- **shared scope 처리**: `strategy_state`의 `scope="shared"`는 LOT과 TREND가 공유하는 리저브 풀이므로, 특정 전략 해제 시 shared scope는 삭제하면 안 됨
- **매도 주문 처리**: OPEN 로트에 대해 거래소에 제출된 매도 주문이 있다면, 전략 해제 전에 주문 취소가 필요할 수 있음. 이 흐름은 사용자에게 안내가 필요
