# 계정 구조 고도화 기획서 (v2)

> 작성일: 2026-02-25
> 검토: Planner + Architect + Critic 3자 합의 (Consensus Planning)
> 대상: crypto-multi-trader (단일 서버, <20 계정)

---

## 1. 배경 및 목적

현재 시스템은 단일 FastAPI 프로세스 안에서 계정별 asyncio task로 매매를 수행한다.
데이터는 `account_id` 기준으로 잘 분리되어 있고, 서킷 브레이커/지수 백오프 등 기본적인 장애 격리도 갖추고 있어 **기본 설계는 양호하다.**

그러나 코드 리뷰 결과 다음과 같은 실질적 취약점이 확인되었다:

- **API 레벨 보안 구멍**: 일부 엔드포인트에 소유권 검증 누락
- **입력 검증 부재**: 위험한 파라미터 값이 그대로 전략에 전달될 수 있음
- **안정성 사각지대**: 서버 재시작 시 장애 상태 소실, 타임아웃 부재
- **추적성 부족**: "누가 무엇을 변경했는지" 확인 불가

이 기획서는 **현재 규모(단일 서버, <20 계정)에 맞는 실용적 개선**에 집중한다.
워커 분리, RLS, 분산 락 같은 엔터프라이즈 패턴은 현 시점에서 비용 대비 효과가 낮아 제외한다.

---

## 2. 현재 구조 진단

### 2.1 양호한 부분

| 항목 | 현황 | 파일 |
|------|------|------|
| 데이터 격리 | 모든 테이블이 `account_id` FK로 분리 | `alembic/versions/001_initial_schema.py` |
| 계정별 실행 격리 | 독립 asyncio Task, 개별 exception 처리 | `app/services/account_trader.py:200-213` |
| 서킷 브레이커 | 5회 연속 실패 시 자동 비활성화 | `app/services/account_trader.py:207-209` |
| API 키 보안 | MultiFernet 암호화 저장 + 키 로테이션 지원 | `app/utils/encryption.py` |
| 계정 API 보안 | 소유권 검증 + admin 체크 | `app/api/accounts.py:58` |
| 대시보드 API 보안 | `_check_account_access()` 헬퍼 | `app/api/dashboard.py:21-27` |

### 2.2 확인된 취약점

| # | 취약점 | 심각도 | 발견 |
|---|--------|--------|------|
| V1 | strategies API 소유권 체크 전무 | **CRITICAL** | Planner/Architect/Critic 전원 확인 |
| V2 | 전략 파라미터 범위 검증 부재 | **HIGH** | Critic 발견, Architect 확인 |
| V3 | dashboard tune 엔드포인트 검증 누락 | **HIGH** | Architect 발견 |
| V4 | HTTP API rate limiting 부재 | **HIGH** | Critic 발견 |
| V5 | AccountUpdate 스키마 범위 제약 누락 | **MEDIUM** | Critic 발견 |
| V6 | `_init_client()` 실패 시 조용한 태스크 종료 | **MEDIUM** | Architect 발견 |
| V7 | `step()` 타임아웃 부재 | **MEDIUM** | Planner 발견 |
| V8 | 서킷 브레이커 상태 재시작 시 소실 | **MEDIUM** | Architect/Critic 발견 |
| V9 | 보안 이벤트 감사 추적 불가 | **LOW** | Planner 발견 |

---

## 3. 구현 계획 (4 Phase)

### Phase 1 — 보안 긴급 수정 (0.5일)

> 해결 대상: V1
> 위험도: 낮음 (기존 패턴 복제)

#### 무엇이 문제인가

`app/api/strategies.py`의 **4개 엔드포인트 전부**에 소유권 검증이 없다.
인증된 사용자라면 아무나 타인의 `account_id`만 알면 전략 설정을 조회/변경/활성화/비활성화할 수 있다.

```
GET  /api/accounts/{account_id}/strategies          → 타인 전략 조회 가능
PUT  /api/accounts/{account_id}/strategies/{name}    → 타인 전략 파라미터 변경 가능
POST /api/accounts/{account_id}/strategies/{name}/enable   → 타인 전략 활성화 가능
POST /api/accounts/{account_id}/strategies/{name}/disable  → 타인 전략 비활성화 가능
```

같은 `account_id` 기반 엔드포인트인 `accounts.py`와 `dashboard.py`에는 소유권 검증이 있지만,
`strategies.py`만 유일하게 빠져 있다. 실거래 자금이 걸린 시스템에서 치명적인 보안 구멍이다.

#### 어떻게 해결하는가

**공통 소유권 검증 Depends 함수를 만들어 모든 계정 관련 API에 통일 적용한다.**

현재 소유권 검증이 3가지 다른 방식으로 흩어져 있다:
- `accounts.py`: `_get_user()` 로컬 함수 + 각 핸들러에서 인라인 체크
- `dashboard.py`: `_check_account_access()` 로컬 함수
- `strategies.py`: 없음

이것을 `app/dependencies.py`에 하나의 FastAPI Depends 함수로 통합한다:

```python
# app/dependencies.py에 추가
async def get_owned_account(
    account_id: UUID,                                    # URL 경로에서 자동 추출
    user: dict = Depends(get_current_user),              # 기존 인증 Depends 재활용
    session: AsyncSession = Depends(get_trading_session), # 기존 DB Depends 재활용
) -> TradingAccount:
    """계정 조회 + 소유권 검증을 한번에 수행. 통과하면 TradingAccount 객체 반환."""
    repo = AccountRepository(session)
    account = await repo.get_by_id(account_id)
    if not account:
        raise HTTPException(404, "Account not found")
    if str(account.owner_id) != user["id"] and user.get("role") != "admin":
        raise HTTPException(403, "Access denied")
    return account
```

이 함수를 FastAPI Depends로 사용하는 이유:
- `dependencies.py`에 이미 `get_current_user`, `require_admin`이 같은 패턴으로 존재
- 계정 조회 + 소유권 검증이 하나의 Depends로 합쳐져 보일러플레이트 제거
- 반환값이 `TradingAccount`이므로 핸들러에서 바로 사용 가능

#### 변경 파일 목록

| 파일 | 변경 내용 |
|------|-----------|
| `app/dependencies.py` | `get_owned_account()` Depends 함수 추가 |
| `app/api/strategies.py` | 4개 엔드포인트에 `get_owned_account` 적용 |
| `app/api/accounts.py` | `_get_user()` 인라인 패턴 → `get_owned_account`로 교체 |
| `app/api/dashboard.py` | `_check_account_access()` → `get_owned_account`로 교체 |

#### 완료 기준

- [ ] `strategies.py` 4개 엔드포인트에서 타 사용자 계정 접근 시 403 반환
- [ ] `list_strategies()` (전략 목록 조회)는 계정 무관이므로 변경 없음
- [ ] 기존 `accounts.py`, `dashboard.py` 기능 동작 변경 없음

---

### Phase 2 — 입력 검증 강화 (0.75일)

> 해결 대상: V2, V3, V4, V5
> 위험도: 낮음~중간 (기존 데이터 호환성 확인 필요)

#### 2-A. 전략 파라미터 범위 검증 (V2, V3)

**무엇이 문제인가**

전략 파라미터를 변경하는 경로가 2개 있는데, 둘 다 범위 검증을 하지 않는다:

1. `PUT /api/accounts/{id}/strategies/{name}` — `strategies.py:44`
2. `POST /api/dashboard/{id}/tune` — `dashboard.py:145`

Pydantic 스키마(`StrategyParamsUpdate`)가 `params: dict[str, Any]`로 완전 개방되어 있고,
`BaseStrategy.validate_params()`는 기본값 병합만 할 뿐 범위 검증을 하지 않는다:

```python
# 현재 validate_params() — 기본값 머지만 수행
def validate_params(self, params):
    return {**self.default_params, **params}  # {"drop_pct": -999} 그대로 통과!
```

이 때문에 `{"drop_pct": -999, "buy_usdt": 99999999}` 같은 위험한 값이 전략에 바로 전달된다.

**어떻게 해결하는가**

각 전략 클래스에 이미 `tunable_params` 딕셔너리가 있고, 여기에 `min`, `max`, `type` 메타데이터가 정의되어 있다 (`app/strategies/lot_stacking.py:52-73`).

이 메타데이터를 활용하여 `BaseStrategy.validate_params()`를 강화한다:
- 각 파라미터의 min/max 범위를 초과하면 `ValueError` 발생 → API에서 422 반환
- 정의되지 않은 키는 무시 (기존 동작 유지)
- `dashboard.py`의 `update_tune` 엔드포인트에도 `validate_params()` 호출 추가

이 방식의 장점:
- `validate_params()`는 **전략 API, 대시보드 tune, 백테스트, 매매 루프** 4곳에서 모두 호출되므로 한 곳만 수정하면 전체에 적용
- 새 전략 추가 시 `tunable_params`만 정의하면 자동으로 검증 적용

**변경 파일 목록**

| 파일 | 변경 내용 |
|------|-----------|
| `app/strategies/base.py` | `validate_params()`에 min/max 범위 검증 로직 추가 |
| `app/api/dashboard.py` | `update_tune`에 `validate_params()` 호출 추가 (현재 단순 dict merge만 수행) |

**완료 기준**

- [ ] `{"drop_pct": -999}` 같은 범위 밖 파라미터 → 422 반환
- [ ] tune 엔드포인트에서도 동일하게 422 반환
- [ ] 기존 정상 범위 파라미터는 문제없이 저장됨

#### 2-B. AccountUpdate 스키마 범위 제약 (V5)

**무엇이 문제인가**

`AccountCreate` 스키마에는 `loop_interval_sec: int = Field(ge=10, le=3600)` 범위 제약이 있지만,
`AccountUpdate` 스키마에는 동일 제약이 없다.

`accounts.py:74-80`에서 `setattr(account, field, val)`로 모델 필드를 직접 대입하므로,
`{"loop_interval_sec": 0}`을 보내면 매매 루프가 0초 간격으로 돌면서 CPU를 100% 점유한다.

**어떻게 해결하는가**

`AccountUpdate` 스키마에 동일한 범위 제약을 추가한다:

```python
# app/schemas/account.py — AccountUpdate에 추가
loop_interval_sec: int | None = Field(None, ge=10, le=3600)
order_cooldown_sec: int | None = Field(None, ge=1, le=300)
```

Pydantic v2에서 `None`(미입력) 시에는 validator가 스킵되므로 Optional 동작에 문제없다.

**변경 파일 목록**

| 파일 | 변경 내용 |
|------|-----------|
| `app/schemas/account.py` | `AccountUpdate`에 `ge`/`le` 범위 제약 추가 |

**완료 기준**

- [ ] `loop_interval_sec: 0` → 422 반환
- [ ] `loop_interval_sec: null` (미입력) → 정상 동작 (기존 값 유지)

#### 2-C. HTTP API Rate Limiting (V4)

**무엇이 문제인가**

현재 `GlobalRateLimiter`는 **바이낸스 거래소 API 호출 속도**만 제한한다.
우리 서버의 HTTP API 엔드포인트에는 호출 횟수 제한이 전혀 없다.

인증된 사용자(또는 유출된 세션 쿠키)로 `/api/dashboard/{id}`를 초당 수천 회 호출하면
DB 커넥션 풀(pool_size=20)이 고갈되고, 같은 풀을 쓰는 **트레이딩 엔진의 매매 루프가 멈출 수 있다.**

**어떻게 해결하는가**

`slowapi` 라이브러리를 도입한다:
- FastAPI/Starlette 전용이라 미들웨어 통합이 간단
- in-memory 저장 (단일 서버에서 Redis 불필요)
- IP 기반 키 함수로 간단하게 시작

적용 기준:

| 엔드포인트 그룹 | 제한 | 이유 |
|-----------------|------|------|
| `/api/auth/*` | 10회/분 | 인증 brute-force 방지 |
| `PUT/POST /api/*/strategies/*` | 30회/분 | 전략 변경 남용 방지 |
| `GET /api/*` (일반 조회) | 120회/분 | DB 풀 보호 |

초과 시 `429 Too Many Requests` + `Retry-After` 헤더를 반환한다.

**변경 파일 목록**

| 파일 | 변경 내용 |
|------|-----------|
| `requirements.txt` | `slowapi` 추가 |
| `app/main.py` | slowapi 미들웨어 등록 |
| `app/api/auth.py` | rate limit 데코레이터 적용 |
| `app/api/strategies.py` | rate limit 데코레이터 적용 |
| `app/api/accounts.py` | rate limit 데코레이터 적용 |
| `app/api/dashboard.py` | rate limit 데코레이터 적용 |

**완료 기준**

- [ ] rate limit 초과 시 429 반환 + `Retry-After` 헤더 포함
- [ ] 정상 사용 시 기존 동작 영향 없음

---

### Phase 3 — 안정성 강화 (1일)

> 해결 대상: V6, V7, V8
> 위험도: 중간 (asyncio 타임아웃 + DB 세션 정리 검증 필요)

#### 3-A. `_init_client()` 실패 처리 (V6) — 최우선

**무엇이 문제인가**

`AccountTrader.run_forever()`가 시작될 때 맨 먼저 `_init_client()`를 호출하여
바이낸스 API 클라이언트를 초기화한다. 그런데 이 호출이 **while 루프 바깥**에 있다:

```python
# app/services/account_trader.py:196-213
async def run_forever(self):
    await self._init_client()   # ← 여기서 예외 발생 시 아래 while 루프에 도달 못함
    while self._running:        #    서킷 브레이커도 작동 안 하고 태스크가 조용히 죽음
        try:
            await self.step()
        except Exception:
            ...
```

`_init_client()`에서 예외가 발생하면 (예: 암호화 키 복호화 실패, DB 연결 실패):
- while 루프에 진입하지 못하므로 **서킷 브레이커가 작동하지 않음**
- asyncio Task가 조용히 종료되어 **아무 경고 없이 해당 계정 매매가 멈춤**
- 대시보드 health에도 반영되지 않음

또한 `TradingEngine.start()` 루프에도 예외 처리가 없어서,
한 계정의 초기화 실패가 **나머지 계정의 시작을 차단**할 수 있다:

```python
# app/services/trading_engine.py:42-45
for i, account in enumerate(accounts):
    jitter = random.uniform(0, 3.0) + (i * 0.5)
    await asyncio.sleep(jitter)
    await self.start_account(account.id)  # ← 여기서 예외 시 다음 계정 시작 안 됨
```

**어떻게 해결하는가**

1. `run_forever()`에서 `_init_client()`를 try-except로 감싸고, 실패 시 서킷 브레이커를 발동시킨다.
2. `TradingEngine.start()` 루프에 try-except를 추가하여 한 계정 실패가 나머지를 차단하지 않게 한다.

**변경 파일 목록**

| 파일 | 변경 내용 |
|------|-----------|
| `app/services/account_trader.py` | `run_forever()`에서 `_init_client()` 예외 처리 추가 |
| `app/services/trading_engine.py` | `start()` 루프에 per-account try-except 추가 |

**완료 기준**

- [ ] 한 계정의 `_init_client()` 실패 시 해당 계정만 비활성화, 나머지 정상 시작
- [ ] 실패한 계정이 health status에 반영됨

#### 3-B. `step()` 타임아웃 (V7)

**무엇이 문제인가**

매매 사이클 `step()` 메서드에 타임아웃이 없다.
바이낸스 API가 응답하지 않으면 해당 계정의 asyncio Task가 **무한 대기** 상태에 빠진다.

이 상태에서는:
- 해당 계정의 매매가 완전히 멈춤
- 서킷 브레이커가 작동하지 않음 (예외가 발생하지 않으므로)
- 다른 계정에는 영향 없지만 (독립 Task), 해당 계정은 수동 재시작 전까지 복구 불가

**어떻게 해결하는가**

`run_forever()`에서 `self.step()` 호출을 `asyncio.wait_for()`로 감싼다:

```python
# 변경 후
try:
    await asyncio.wait_for(self.step(), timeout=180)  # 3분 타임아웃
except asyncio.TimeoutError:
    self._consecutive_failures += 1  # 서킷 브레이커 카운트 증가
    logger.error(f"[{self.account_id}] step() timed out (180s)")
```

타임아웃 값 180초(3분)의 근거:
- 바이낸스 API 호출이 보통 1-5초, 최악의 경우에도 30초 이내
- `_sync_orders_and_fills`에서 최대 50개 주문을 순차 조회 (50 * 5초 = 250초가 이론적 최악이지만, rate limiter가 있어 현실적으로 120초 이내)
- 3분이면 정상 동작의 여유를 충분히 커버하면서 무한 대기를 방지

**변경 파일 목록**

| 파일 | 변경 내용 |
|------|-----------|
| `app/services/account_trader.py` | `run_forever()`에 `asyncio.wait_for` 타임아웃 래핑 |

**완료 기준**

- [ ] step() 180초 초과 시 타임아웃 에러 발생
- [ ] 타임아웃이 서킷 브레이커 failure로 카운트됨
- [ ] DB 세션이 정상 정리됨 (`async with` 컨텍스트 매니저가 CancelledError 처리)

#### 3-C. 서킷 브레이커 상태 DB 복원 (V8)

**무엇이 문제인가**

서킷 브레이커 상태가 인메모리에만 존재한다:

```python
# app/services/account_trader.py:53
self._consecutive_failures = 0  # 서버 재시작 시 항상 0으로 초기화
```

서킷 브레이커가 발동(5회 연속 실패)하여 계정이 비활성화되었더라도,
서버를 재시작하면 `_consecutive_failures`가 0으로 리셋되어 **장애 계정이 다시 실행된다.**

실제로 DB에는 `circuit_breaker_failures` 컬럼이 이미 존재하고,
`_disable_with_circuit_breaker()`가 비활성화 시 DB에 기록하고 있다.
문제는 **서버 시작 시 DB 값을 읽어오지 않는 것**이다.

**어떻게 해결하는가**

1. `AccountTrader.__init__()` 또는 `_init_client()`에서 DB의 `circuit_breaker_failures` 값을 읽어 `_consecutive_failures`를 초기화한다.
2. API `start_account()` 호출 시 해당 계정의 서킷 브레이커 상태를 확인하여, 비활성 계정 시작을 차단한다 (관리자가 먼저 리셋해야 함).
3. `app/services/rate_limiter.py`에 정의만 있고 **사용되지 않는** `CircuitBreaker` 클래스를 제거한다 (dead code 정리).

**변경 파일 목록**

| 파일 | 변경 내용 |
|------|-----------|
| `app/services/account_trader.py` | 초기화 시 DB에서 failure count 복원 |
| `app/services/trading_engine.py` | `start_account()`에 서킷 브레이커 상태 검증 추가 |
| `app/services/rate_limiter.py` | 미사용 `CircuitBreaker` 클래스 제거 |

**완료 기준**

- [ ] 서킷 브레이커 발동 후 서버 재시작 시 해당 계정 자동 재실행 안 됨
- [ ] 관리자 리셋(`reset-circuit-breaker`) 후에만 계정 시작 가능
- [ ] dead code `CircuitBreaker` 클래스 제거 확인

---

### Phase 4 — 감사 로깅 (0.5일)

> 해결 대상: V9
> 위험도: 낮음 (기존 로깅 인프라 활용)

#### 무엇이 문제인가

현재 구조화된 로깅(`utils/logging.py`)은 매매 루프의 기술적 이벤트(주문 생성, 체결 등)를 기록하지만,
**"누가 무엇을 변경했는지"** 추적하는 보안 감사 로그가 없다.

예를 들어:
- 관리자가 타인 계정의 전략 파라미터를 변경한 이력
- 계정 시작/중지 이력
- 서킷 브레이커 리셋 이력

문제가 발생했을 때 원인을 추적하기 어렵다.

#### 어떻게 해결하는가

별도 DB 테이블 없이, **구조화된 JSON 로깅**으로 구현한다.

기존 `app/utils/logging.py`에 `audit` 전용 로거를 추가하고,
보안 관련 엔드포인트에서 구조화된 JSON 로그를 출력한다:

```json
{
  "event": "strategy_params_changed",
  "user_id": "abc-123",
  "account_id": "def-456",
  "strategy": "lot_stacking",
  "changes": {"drop_pct": {"old": 3.0, "new": 5.0}},
  "ts": "2026-02-25T10:00:00Z"
}
```

이 방식의 장점:
- DB 스키마 변경 없음 (마이그레이션 불필요)
- 기존 로깅 인프라(StructuredFormatter)를 그대로 활용
- 로그 파일 기반으로 `grep`/`jq`로 검색 가능
- 추후 ELK 등 로그 분석 도구 도입 시 자연스럽게 확장

대상 이벤트:

| 이벤트 | 트리거 위치 |
|--------|------------|
| `strategy_params_changed` | `strategies.py` PUT, `dashboard.py` tune POST |
| `strategy_enabled` / `strategy_disabled` | `strategies.py` enable/disable |
| `account_started` / `account_stopped` | `accounts.py` start/stop |
| `circuit_breaker_reset` | `accounts.py` reset-circuit-breaker |
| `account_created` / `account_deleted` | `accounts.py` POST/DELETE |

#### 변경 파일 목록

| 파일 | 변경 내용 |
|------|-----------|
| `app/utils/logging.py` | `audit` 전용 로거 + 헬퍼 함수 추가 |
| `app/api/strategies.py` | 전략 변경/활성화/비활성화 시 audit 로그 호출 |
| `app/api/accounts.py` | 계정 생성/삭제/시작/중지/서킷 브레이커 리셋 시 audit 로그 호출 |
| `app/api/dashboard.py` | tune 변경 시 audit 로그 호출 |

#### 완료 기준

- [ ] 전략 변경 시 audit 로그에 user_id, account_id, 변경 내용 기록
- [ ] 계정 조작 시 audit 로그에 이벤트 기록
- [ ] 로그 포맷: JSON 구조화, `event`/`user_id`/`account_id`/`ts` 필수 필드 포함

---

## 4. 제외 항목 및 근거

### 4.1 DB RLS (Row Level Security)

**v1 기획서**: "상" 우선순위로 RLS 도입 제안

**제외 이유**:
- 트레이딩 엔진이 의도적으로 RLS를 바이패스하는 것이 현재 설계의 전제 (`app/db/session.py`)
- RLS를 켜면 엔진의 모든 DB 세션이 `auth.uid()` 컨텍스트를 필요로 하는데, SQLAlchemy 직접 연결에서는 이 컨텍스트가 없음
- 잘못 적용 시 **매매 루프 전체 정지** → 실제 자금 손실 가능
- Phase 1의 앱 레벨 소유권 검증 통일로 충분히 방어 가능

### 4.2 Control Plane / Worker Plane 분리

**v1 기획서**: "상" 우선순위로 워커 프로세스 분리 제안

**제외 이유**:
- <20 계정 단일 서버에서 프로세스 분리는 운영 복잡성만 증가 (systemd 유닛 1개 → 최소 3개)
- 계정 간 장애 격리는 이미 asyncio Task + 서킷 브레이커로 충분
- IPC 통신 레이어, PriceCollector 재설계 등 부수 작업량이 과도
- 프로세스 크래시는 systemd `Restart=always`로 이미 대응 중

**재검토 시점**: 계정 50개 이상 또는 다중 서버 배포 필요 시

### 4.3 분산 락

**v1 기획서**: "중" 우선순위로 분산 락 도입 제안

**제외 이유**:
- 단일 프로세스에서 `if account_id in self._tasks: return` (`trading_engine.py:48`)으로 중복 실행 방지 완료
- 분산 락은 다중 인스턴스 환경에서만 의미가 있음

**재검토 시점**: 다중 인스턴스 배포 전환 시

### 4.4 Market Data Service / Notification Service 분리

**v1 기획서**: 별도 서비스로 분리 제안

**제외 이유**:
- `PriceCollector`가 이미 심볼별 캐시 + 중복 방지를 수행 중
- 알림 시스템 자체가 아직 존재하지 않음 (없는 것을 분리할 수 없음)
- 별도 서비스 = 네트워크 홉 추가 + 장애점 증가

---

## 5. 총 예상 공수

| Phase | 내용 | 공수 | 위험도 |
|-------|------|------|--------|
| Phase 1 | 보안 긴급 수정 (소유권 검증 통일) | 0.5일 | 낮음 |
| Phase 2 | 입력 검증 강화 (파라미터 범위 + rate limiting) | 0.75일 | 낮음~중간 |
| Phase 3 | 안정성 강화 (init 실패 처리 + 타임아웃 + CB 복원) | 1일 | 중간 |
| Phase 4 | 감사 로깅 | 0.5일 | 낮음 |
| **합계** | | **2.75일** | |

---

## 6. 구현 시 주의사항

### Phase 2 주의사항
- `validate_params()` 수정 시 **이미 DB에 저장된 기존 파라미터**와의 호환성 확인 필요
- 기존 값이 새로운 범위 검증에 걸리면 전략 로드 시 에러 발생 가능
- 해결: 런타임 `validate_params`에서는 경고만 출력하고 API 입력에서만 거부하거나, 기존 값이 범위 밖이면 자동으로 범위 내 값으로 클램핑

### Phase 3 주의사항
- `asyncio.wait_for()` 타임아웃 시 `CancelledError`가 발생하는데, `async with TradingSessionLocal()` 컨텍스트 매니저가 이를 정상 처리하는지 확인 필요
- `_init_client()` 실패 처리 시 `self._client = None` 상태에서 `step()` 호출되지 않도록 방어 코드 필요
- 서킷 브레이커 DB 복원 시, `is_active=False`이면서 `circuit_breaker_failures >= 5`인 계정은 `start()` 루프에서 자동 스킵되어야 함 (현재 `get_active_accounts()`가 `is_active=True`만 가져오므로 엔진 시작 시에는 문제없으나, API `start_account()` 호출 시 별도 검증 필요)
