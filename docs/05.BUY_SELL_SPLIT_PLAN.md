# 매수/매도 로직 분리 및 조합 시스템 설계 (정제본)

> 작성일: 2026-02-25
> 상태: **정제 완료** (코드 분석 기반 검증 완료)
> 대상: crypto-multi-trader
> 이전 버전: 1차 초안 (2026-02-25)

---

## 1. 배경 및 현황

### 현재 구조

현재 전략은 `BaseStrategy`를 상속한 단일 클래스에 **매수 + 매도 로직이 합쳐져** 있다:

```
BaseStrategy (ABC)                   [app/strategies/base.py]
├── tick()          <- 매수 + 매도 모두 실행
├── on_fill()       <- 체결 후처리 (현재 양쪽 모두 빈 구현)
├── validate_params()
├── default_params  <- 매수/매도 파라미터가 하나의 dict에 혼재
└── tunable_params

LotStackingStrategy(BaseStrategy)    [app/strategies/lot_stacking.py]
├── _maybe_buy_on_drop()       <- 매수 로직
├── _process_pending_buy()     <- 매수 주문 관리 (INIT/LOT 분기)
├── _handle_filled_buy()       <- 매수 체결 처리 (INIT: reserve 설정, LOT: 로트 생성)
├── _maybe_recenter_base()     <- 매수 기준가 관리
├── _maybe_take_profit()       <- 매도 로직 (고정 익절)
├── _extract_base_commission_qty()  <- 헬퍼 (중복)
├── _extract_fee_usdt()             <- 헬퍼 (중복)
├── _cooldown_ok()                  <- 인스턴스 메서드
└── _touch_order()                  <- 인스턴스 메서드

TrendBuyStrategy(BaseStrategy)       [app/strategies/trend_buy.py]
├── _maybe_buy_on_trend()           <- 매수 로직
│   └── lot_stacking scope의 base_price 직접 참조 (cross-strategy)
├── _process_pending_trend_buy()    <- 매수 주문 관리
├── _handle_filled_trend_buy()      <- 매수 체결 처리
├── _maybe_take_profit_trends()     <- 매도 로직 -- lot_stacking과 95% 동일
├── _extract_base_commission_qty()  <- 헬퍼 (중복)
├── _extract_fee_usdt()             <- 헬퍼 (중복)
├── _cooldown_ok()                  <- 인스턴스 메서드 (중복)
└── _touch_order()                  <- 인스턴스 메서드 (중복)
```

### 문제점

1. **매도 로직 중복**: `_maybe_take_profit()`과 `_maybe_take_profit_trends()`는 95% 동일한 코드 (약 120줄 중복)
2. **매도 전략 변경 불가**: 매수와 매도가 한 클래스에 결합되어, 매도만 변경하려면 전체 전략 수정 필요
3. **향후 확장 어려움**: 트레일링 매도, 분할매도 등 새 매도 방식 추가 시 모든 매수 전략에 개별 구현해야 함
4. **조합 불가**: "LOT 적립 매수 + 트레일링 매도" 같은 자유 조합이 불가능
5. **헬퍼 중복**: `_extract_base_commission_qty`, `_extract_fee_usdt`, `_cooldown_ok`, `_touch_order`가 양쪽에 복사
6. **Cross-strategy 참조 하드코딩**: `trend_buy`가 `"lot_stacking"` 문자열 scope로 직접 state 접근

### 영향 범위 (코드 분석 결과)

변경 필요한 파일 목록:

| 구분 | 파일 | 변경 유형 |
|------|------|-----------|
| 핵심 | `app/strategies/base.py` | 새 기본 클래스 추가 |
| 핵심 | `app/strategies/registry.py` | 새 레지스트리 추가 |
| 핵심 | `app/strategies/lot_stacking.py` | 매수 로직 추출 후 제거 |
| 핵심 | `app/strategies/trend_buy.py` | 매수 로직 추출 후 제거 |
| 핵심 | `app/services/account_trader.py` | 실행 루프 전환 |
| DB | `app/models/lot.py` | `combo_id` 컬럼 추가 |
| DB | `app/models/strategy_config.py` | 유지 (마이그레이션 후 제거) |
| DB | `app/models/__init__.py` | `TradingCombo` 모델 등록 |
| DB | `app/models/account.py` | `trading_combos` relationship 추가 |
| DB | `app/db/lot_repo.py` | `get_open_lots_by_combo()`, `insert_lot` combo_id 추가 |
| API | `app/api/strategies.py` | combo CRUD로 전환 |
| API | `app/api/dashboard.py` | 하드코딩된 전략명 제거, combo 기반 |
| Schema | `app/schemas/strategy.py` | combo 스키마 추가 |
| Schema | `app/schemas/dashboard.py` | `TuneUpdate` -> combo 파라미터 |
| Schema | `app/schemas/trade.py` | `LotResponse`에 `combo_id` 추가 |
| UI | `app/dashboard/templates/account_detail.html` | combo UI로 전환 |
| UI | `app/dashboard/static/js/main.js` | combo 관련 JS |
| 백테스트 | `backtest/isolated_runner.py` | combo 기반 실행 전환 |
| 신규 | `app/strategies/buys/lot_stacking.py` | 매수 로직 |
| 신규 | `app/strategies/buys/trend.py` | 추세 매수 로직 |
| 신규 | `app/strategies/sells/fixed_tp.py` | 고정 익절 로직 |
| 신규 | `app/strategies/utils.py` | 공통 헬퍼 |
| 신규 | `app/models/trading_combo.py` | SQLAlchemy 모델 |
| 신규 | `alembic/versions/003_trading_combos.py` | DB 마이그레이션 |

---

## 2. 핵심 설계 결정: 1:1 조합 모델 (확정)

### 결론

```
+-------------------------------------------------+
|  매매 조합 (Trading Combo)                       |
|                                                  |
|  +-------------- +    +--------------+           |
|  |  매수 로직    |    |  매도 로직    |           |
|  |  (1개)       | +  |  (1개)       | = 1 조합  |
|  +--------------+    +--------------+           |
|                                                  |
|  계정당 여러 조합 활성 가능                        |
+-------------------------------------------------+

예시: 계정 A의 활성 조합들
  조합 1: LOT 적립 매수 + 고정 익절 (tp_pct=3.3%)
  조합 2: 추세 매수     + 고정 익절 (tp_pct=3.0%)
  조합 3: LOT 적립 매수 + 트레일링 매도 (trail_pct=2%)  <- 미래
```

### 1:1 모델 채택 이유 (요약)

1. **매도 로직은 이미 로트 단위**: 개별 로트마다 익절 판단하므로 매수 로직 수에 무관
2. **엄격히 더 유연**: "LOT적립 -> 트레일링, 추세 -> 고정익절" 같은 이종 조합 가능
3. **편리함은 UX로 해결**: 매도 설정 복사, 프리셋, 조합 복제 등 대시보드 기능으로 커버
4. **상태 관리 단순**: 각 조합이 독립된 state scope 소유 (combo_id)

---

## 3. 아키텍처 상세

### 3-1. 새 기본 클래스

```python
# app/strategies/base.py -- 기존 유지 + 추가

@dataclass
class StrategyContext:
    """기존 그대로 유지"""
    account_id: UUID
    symbol: str
    base_asset: str
    quote_asset: str
    current_price: float
    params: Dict[str, Any]
    client_order_prefix: str


@dataclass
class RepositoryBundle:
    """기존 그대로 유지"""
    lot: "LotRepository"
    order: "OrderRepository"
    position: "PositionRepository"
    price: "PriceRepository"


class BaseStrategy(ABC):
    """기존 유지 (하위호환, 백테스트 전환 전 유지)"""
    ...


class BaseBuyLogic(ABC):
    """매수 전용 플러그인"""
    name: str = ""
    display_name: str = ""
    description: str = ""
    version: str = "1.0.0"
    default_params: Dict[str, Any] = {}
    tunable_params: Dict[str, Dict[str, Any]] = {}

    def __init__(self):
        self._last_order_ts: float = 0.0

    async def pre_tick(
        self, ctx: StrategyContext, state: StrategyStateStore,
        exchange: ExchangeClient, repos: RepositoryBundle, combo_id: UUID,
    ) -> None:
        """매도 실행 이전에 호출 (기본: no-op). recenter 등 base_price 순서 보호가 필요한 로직 배치."""
        pass

    @abstractmethod
    async def tick(
        self, ctx: StrategyContext, state: StrategyStateStore,
        exchange: ExchangeClient, account_state: AccountStateManager,
        repos: RepositoryBundle, combo_id: UUID,
    ) -> None:
        """매수 로직 1 사이클 (매도 실행 이후에 호출)."""

    def validate_params(self, params: Dict[str, Any]) -> Dict[str, Any]:
        return {**self.default_params, **params}

    # 공통 인스턴스 메서드 (base에 배치)
    def _cooldown_ok(self, cooldown_sec: float) -> bool:
        return (time.time() - self._last_order_ts) >= cooldown_sec

    def _touch_order(self) -> None:
        self._last_order_ts = time.time()


class BaseSellLogic(ABC):
    """매도 전용 플러그인"""
    name: str = ""
    display_name: str = ""
    description: str = ""
    version: str = "1.0.0"
    default_params: Dict[str, Any] = {}
    tunable_params: Dict[str, Dict[str, Any]] = {}

    def __init__(self):
        self._last_order_ts: float = 0.0

    @abstractmethod
    async def tick(
        self, ctx: StrategyContext, state: StrategyStateStore,
        exchange: ExchangeClient, account_state: AccountStateManager,
        repos: RepositoryBundle, open_lots: list,
    ) -> None:
        """매도 로직 1 사이클. open_lots는 이 조합의 미결 로트들."""

    def validate_params(self, params: Dict[str, Any]) -> Dict[str, Any]:
        return {**self.default_params, **params}

    def _cooldown_ok(self, cooldown_sec: float) -> bool:
        return (time.time() - self._last_order_ts) >= cooldown_sec

    def _touch_order(self) -> None:
        self._last_order_ts = time.time()
```

**설계 결정: `on_fill()` 메서드 생략**

현재 `BaseStrategy.on_fill()`은 양쪽 구현 모두 빈 `pass`이다.
새 `BaseBuyLogic`과 `BaseSellLogic`에는 `on_fill()`을 추가하지 않는다.
향후 WebSocket 체결 알림이 필요해지면 그때 추가한다.

### 3-2. 공통 헬퍼 모듈

```python
# app/strategies/utils.py -- 신규

def extract_base_commission_qty(order_data: dict, base_asset: str) -> float:
    """주문 fills에서 base asset 수수료 총합 추출"""
    fills = order_data.get("fills", [])
    total = 0.0
    for fill in fills:
        if str(fill.get("commissionAsset", "")).upper() == base_asset.upper():
            total += float(fill.get("commission", 0))
    return total


def extract_fee_usdt(order_data: dict, quote_asset: str) -> float:
    """주문 fills에서 quote asset 수수료 총합 추출"""
    fills = order_data.get("fills", [])
    total = 0.0
    for fill in fills:
        if str(fill.get("commissionAsset", "")).upper() == quote_asset.upper():
            total += float(fill.get("commission", 0))
    return total
```

**근거**: `_extract_base_commission_qty`와 `_extract_fee_usdt`가 `lot_stacking.py`와 `trend_buy.py`에 완전 동일하게 중복. 모듈 함수로 추출하여 양쪽 매수/매도 로직에서 import.

### 3-3. 레지스트리 분리

```python
# app/strategies/registry.py -- 기존 유지 + 추가

class StrategyRegistry:
    """기존 유지 (백테스트 전환 전까지 하위호환)"""
    ...

class BuyLogicRegistry:
    _buy_logics: dict[str, type[BaseBuyLogic]] = {}

    @classmethod
    def register(cls, buy_logic_class):
        cls._buy_logics[buy_logic_class.name] = buy_logic_class
        return buy_logic_class

    @classmethod
    def get(cls, name: str) -> type[BaseBuyLogic]:
        if name not in cls._buy_logics:
            raise KeyError(f"Unknown buy logic: {name}")
        return cls._buy_logics[name]

    @classmethod
    def create_instance(cls, name: str) -> BaseBuyLogic:
        return cls.get(name)()

    @classmethod
    def list_all(cls) -> list[dict]:
        return [
            {"name": c.name, "display_name": c.display_name,
             "description": c.description, "version": c.version,
             "default_params": c.default_params, "tunable_params": c.tunable_params}
            for c in (cls._buy_logics[k]() for k in cls._buy_logics)
        ]


class SellLogicRegistry:
    _sell_logics: dict[str, type[BaseSellLogic]] = {}

    @classmethod
    def register(cls, sell_logic_class):
        cls._sell_logics[sell_logic_class.name] = sell_logic_class
        return sell_logic_class

    @classmethod
    def get(cls, name: str) -> type[BaseSellLogic]:
        if name not in cls._sell_logics:
            raise KeyError(f"Unknown sell logic: {name}")
        return cls._sell_logics[name]

    @classmethod
    def create_instance(cls, name: str) -> BaseSellLogic:
        return cls.get(name)()

    @classmethod
    def list_all(cls) -> list[dict]:
        return [
            {"name": c.name, "display_name": c.display_name,
             "description": c.description, "version": c.version,
             "default_params": c.default_params, "tunable_params": c.tunable_params}
            for c in (cls._sell_logics[k]() for k in cls._sell_logics)
        ]
```

### 3-4. 파일 구조

```
app/strategies/
├── base.py                <- StrategyContext, RepositoryBundle, BaseStrategy(기존),
│                             BaseBuyLogic(신규), BaseSellLogic(신규)
├── registry.py            <- StrategyRegistry(기존유지) + BuyLogicRegistry + SellLogicRegistry
├── state_store.py         <- 변경 없음
├── utils.py               <- 신규: extract_base_commission_qty, extract_fee_usdt
├── buys/
│   ├── __init__.py        <- 자동 import (LotStackingBuy, TrendBuy)
│   ├── lot_stacking.py    <- LotStackingBuy
│   └── trend.py           <- TrendBuy
├── sells/
│   ├── __init__.py        <- 자동 import (FixedTpSell)
│   └── fixed_tp.py        <- FixedTpSell
├── lot_stacking.py        <- 기존 (Phase 5에서 제거)
└── trend_buy.py           <- 기존 (Phase 5에서 제거)
```

### 3-5. 실행 흐름 변경

**현재:**
```
account_trader.step()
  -> strategy_configs에서 is_enabled=True 로드
  -> for each config:
      state = StrategyStateStore(account_id, strategy_name, session)
      strategy.tick(ctx, state, exchange, ...)  <- 매수+매도 한번에
```

**변경 후:**
```
account_trader.step()
  -> trading_combos에서 is_enabled=True 로드
  -> for each combo:
      combo_state = StrategyStateStore(account_id, str(combo.id), session)

      # 1. 매수 로직의 recenter 먼저 (base_price 보호를 위해)
      buy_logic.pre_tick(buy_ctx, combo_state, exchange, repos, combo.id)
        └── _maybe_recenter_base() 만 실행

      # 2. 매도 (기존 로트 관리, TP 체결 시 base_price 갱신)
      open_lots = lot_repo.get_open_lots_by_combo(account_id, symbol, combo.id)
      sell_logic.tick(sell_ctx, combo_state, exchange, ..., open_lots)

      # 3. 매수 (pending 처리 + 새 로트 생성)
      buy_logic.tick(buy_ctx, combo_state, exchange, ..., combo.id)
        └── _process_pending_buy() -> _maybe_buy_on_drop()  (recenter 제외)
```

**이 실행 순서의 근거 (Architect/Critic 리뷰 반영):**

현재 `lot_stacking.tick()` 내부 순서:
```
1. _process_pending_buy   (base_price write 가능)
2. _maybe_recenter_base   (base_price write 가능)
3. _maybe_take_profit     (base_price write 가능: TP 체결 시)
4. _maybe_buy_on_drop     (base_price read)
```

**문제**: 매도/매수를 단순 분리하면 `sell.tick() [TP→base_price=sell_price]` → `buy.tick() [recenter→base_price=ema]` 순서가 되어, TP가 갱신한 base_price를 recenter가 덮어쓸 수 있다.

**해결**: recenter를 매도 **이전에** 실행하여 현재와 동등한 순서를 보존한다:
- recenter(2번) → TP(3번) → pending_buy(1번) → buy_on_drop(4번)
- 현재 코드에서도 recenter가 TP보다 먼저이므로, TP의 base_price 갱신이 최종값이 되는 동작이 보존됨
- `BaseBuyLogic`에 `pre_tick()` 메서드를 추가하여 recenter만 분리 실행

**매도를 매수보다 먼저 실행하는 이유:**
- 매도 체결 시 `core_bucket_usdt`에 수익 적립
- 이후 매수 시 해당 수익을 추가 매수금에 포함 (현재 로직과 동일)

**새 로트의 TP 주문 1 tick 지연 (수용):**
- 매수가 매도 이후에 실행되므로, 이번 tick에서 체결된 매수로 생성된 새 로트는 다음 tick에서 TP 주문이 배치됨
- 현재 코드에서도 `_maybe_buy_on_drop`(4번)이 `_maybe_take_profit`(3번) 이후이므로 동일한 1-tick 지연이 이미 존재
- loop_interval 60초 기준 최대 60초 지연이며, 실질적 영향은 미미함

### 3-6. 상태(State) 공유 모델

**한 조합 내에서 매수/매도 로직은 동일한 state scope를 공유한다.**

```
StrategyStateStore(account_id, combo_id, session)
  +-- base_price          <- 매수가 write (buy_on_drop/recenter), 매도가 TP 체결 시 write
  +-- pending_order_id    <- 매수가 관리
  +-- pending_time_ms     <- 매수가 관리
  +-- pending_bucket_usdt <- 매수가 관리 (키 이름 통일, 아래 설명)
  +-- pending_trigger_price <- 매수가 관리
  +-- pending_kind        <- 매수가 관리 (lot_stacking 전용: INIT/LOT)
  +-- core_bucket_usdt    <- 매도가 write (수익 적립), 매수가 read (추가 매수)
  +-- recenter_ema        <- 매수가 관리 (lot_stacking 전용)
  +-- last_buy_price      <- 매수가 관리 (trend_buy 전용)
  +-- ...
```

**state 키 통일 사항:**

현재 lot_stacking은 `pending_core_bucket_usdt`, trend_buy는 `pending_trend_bucket_usdt`를 사용한다.
분리 후에는 `pending_bucket_usdt`로 통일한다. 어차피 scope가 combo_id로 격리되므로 충돌 없음.

### 3-7. base_price 업데이트 동작 차이 처리

**문제**: 매도 체결 시 `base_price` 업데이트 로직이 다르다:
- lot_stacking: 무조건 `base_price = sell_price` (라인 399)
- trend_buy: `sell_price > current base`일 때만 업데이트 (라인 301-303)

**해결**: `FixedTpSell`에 `base_price_update_mode` 파라미터 추가:
- `"always"` (기본값, lot_stacking 동작): 항상 sell_price로 갱신
- `"if_higher"` (trend_buy 동작): sell_price가 현재 base보다 높을 때만 갱신

```python
# sells/fixed_tp.py 내부
base_mode = ctx.params.get("base_price_update_mode", "always")
if base_mode == "always":
    await state.set("base_price", sell_price)
elif base_mode == "if_higher":
    current_base = await state.get_float("base_price", 0.0)
    if sell_price > current_base:
        await state.set("base_price", sell_price)
```

이렇게 하면 FixedTpSell 하나로 양쪽 동작을 모두 커버한다.
마이그레이션 시:
- lot_stacking combo의 sell_params: `{"tp_pct": 0.033, "base_price_update_mode": "always"}`
- trend_buy combo의 sell_params: `{"tp_pct": 0.03, "base_price_update_mode": "if_higher"}`

---

## 4. DB 스키마 변경

### 4-1. 신규 테이블: `trading_combos`

```sql
CREATE TABLE trading_combos (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    account_id      UUID NOT NULL REFERENCES trading_accounts(id) ON DELETE CASCADE,
    name            VARCHAR NOT NULL,         -- 사용자 지정 이름 (예: "BTC 적립매수 고정익절")
    buy_logic_name  VARCHAR NOT NULL,         -- 매수 로직 이름 (예: "lot_stacking")
    buy_params      JSONB NOT NULL DEFAULT '{}',
    sell_logic_name VARCHAR NOT NULL,         -- 매도 로직 이름 (예: "fixed_tp")
    sell_params     JSONB NOT NULL DEFAULT '{}',
    reference_combo_id UUID REFERENCES trading_combos(id) ON DELETE SET NULL,
                                              -- cross-combo 참조 (trend_buy -> lot_stacking base_price)
    CONSTRAINT chk_no_self_reference CHECK (reference_combo_id != id),
    is_enabled      BOOLEAN NOT NULL DEFAULT true,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_combos_account ON trading_combos(account_id, is_enabled);
```

**`reference_combo_id` 설명:**
trend_buy가 lot_stacking의 `base_price`를 참조하는 현재 cross-strategy 의존성을 명시적으로 모델링.
상세 내용은 섹션 7(Cross-combo 참조) 참조.

**`chk_no_self_reference` 제약조건:** 자기 자신을 참조하는 순환 참조를 DB 수준에서 방지.
API 레벨에서도 `reference_combo_id != combo.id` 검증을 중복 수행한다.

### 4-2. `lots` 테이블 변경

```sql
ALTER TABLE lots ADD COLUMN combo_id UUID REFERENCES trading_combos(id);
CREATE INDEX idx_lots_combo ON lots(account_id, combo_id, status);
```

- 기존 로트: 마이그레이션 시 `combo_id` 채움 (strategy_name 기반 매핑)
- 새 로트: `combo_id` 필수, `strategy_name`도 매수 로직명으로 유지 (표시/하위호환)

### 4-3. `strategy_state` 활용 변경

기존 `scope` 사용:
- `scope = "lot_stacking"` -- 전략 이름 문자열

변경 후 `scope` 사용:
- `scope = "{combo_id}"` -- 조합 ID (UUID 문자열)

`StrategyStateStore` 클래스 자체는 변경 없음 (scope를 문자열로 받으므로).

### 4-4. `strategy_configs` 테이블

**마이그레이션 완료 후 제거 대상.**
전환 기간(Phase 2~3) 동안 유지하되, `account_trader.py`는 Phase 3부터 `trading_combos`만 참조.

### 4-5. `TradingAccount` 모델 변경

```python
# app/models/account.py
class TradingAccount(Base):
    ...
    strategy_configs = relationship(...)  # 기존 유지 (Phase 5에서 제거)
    trading_combos = relationship("TradingCombo", back_populates="account",
                                  cascade="all, delete-orphan")  # 신규 추가
```

---

## 5. 코드 변경 상세

### 5-1. 매수 로직: LotStackingBuy

```python
# app/strategies/buys/lot_stacking.py

from app.strategies.utils import extract_base_commission_qty

@BuyLogicRegistry.register
class LotStackingBuy(BaseBuyLogic):
    name = "lot_stacking"
    display_name = "LOT 적립 매수"
    description = "기준가 하락 시 분할 매수, 리저브 BTC 적립"
    version = "1.0.0"

    default_params = {
        "buy_usdt": 100.0,
        "drop_pct": 0.006,
        "prebuy_pct": 0.0015,
        "cancel_rebound_pct": 0.004,
        "min_trade_usdt": 6.0,
        "recenter_enabled": True,
        "recenter_pct": 0.02,
        "recenter_ema_n": 40,
        "use_fixed_usdt_reference": True,
    }
    # 주의: tp_pct 없음 (매도 파라미터이므로)

    tunable_params = {
        "buy_usdt": {...},
        "drop_pct": {...},
        "recenter_pct": {...},
        "recenter_ema_n": {...},
    }

    async def pre_tick(self, ctx, state, exchange, repos, combo_id):
        """매도 실행 이전에 호출. recenter만 수행하여 base_price 순서 보존."""
        await self._maybe_recenter_base(ctx, state, exchange, repos, combo_id)

    async def tick(self, ctx, state, exchange, account_state, repos, combo_id):
        """매도 실행 이후에 호출. pending 처리 + 신규 매수."""
        has_pending = await self._process_pending_buy(ctx, state, exchange, account_state, repos, combo_id)
        # recenter는 pre_tick()에서 이미 실행됨 — 여기서는 skip
        if not has_pending:
            await self._maybe_buy_on_drop(ctx, state, exchange, account_state, repos, combo_id)

    # 메서드 이동 목록:
    # _process_pending_buy   <- lot_stacking.py L108-181 그대로
    # _handle_filled_buy     <- lot_stacking.py L187-277 (insert_lot에 combo_id 추가)
    # _maybe_recenter_base   <- lot_stacking.py L282-325 (get_open_lots -> get_open_lots_by_combo)
    # _maybe_buy_on_drop     <- lot_stacking.py L459-535 그대로
    # _update_recenter_ema   <- lot_stacking.py L315-325 그대로
```

**변경 포인트:**
1. `insert_lot()` 호출 시 `combo_id` 파라미터 추가
2. `get_open_lots()` -> `get_open_lots_by_combo(account_id, symbol, combo_id)` (recenter에서 사용)
3. `_extract_base_commission_qty` -> `utils.extract_base_commission_qty` import
4. `pending_core_bucket_usdt` 키 -> `pending_bucket_usdt`로 변경
5. `strategy_name="lot_stacking"` 하드코딩 -> `strategy_name=self.name` (insert_lot에서)

### 5-2. 매수 로직: TrendBuy

```python
# app/strategies/buys/trend.py

@BuyLogicRegistry.register
class TrendBuy(BaseBuyLogic):
    name = "trend_buy"
    display_name = "추세 매수"
    description = "상승 추세 되돌림 시 분할 매수"
    version = "1.0.0"

    default_params = {
        "buy_usdt": 50.0,
        "enable_pct": 0.03,
        "recenter_pct": 0.02,
        "drop_pct": 0.01,
        "step_pct": 0.01,
        "min_trade_usdt": 6.0,
    }
    # 주의: tp_pct 없음

    async def tick(self, ctx, state, exchange, account_state, repos, combo_id):
        has_pending = await self._process_pending_trend_buy(ctx, state, exchange, account_state, repos, combo_id)
        if not has_pending:
            await self._maybe_buy_on_trend(ctx, state, exchange, account_state, repos, combo_id)

    # _maybe_buy_on_trend 변경사항:
    # 기존: lot_state = StrategyStateStore(ctx.account_id, "lot_stacking", state._session)
    # 변경: reference_combo_id를 통해 참조 (섹션 7 참조)
```

**변경 포인트:**
1. Cross-strategy `base_price` 참조 -> `reference_combo_id` 기반 (섹션 7 상세)
2. `pending_trend_bucket_usdt` -> `pending_bucket_usdt`
3. `strategy_name="trend_buy"` -> `strategy_name=self.name`
4. `insert_lot()` 호출 시 `combo_id` 추가

### 5-3. 매도 로직: FixedTpSell

```python
# app/strategies/sells/fixed_tp.py

from app.strategies.utils import extract_fee_usdt

@SellLogicRegistry.register
class FixedTpSell(BaseSellLogic):
    name = "fixed_tp"
    display_name = "고정 비율 익절"
    description = "매수가 대비 고정 비율 상승 시 익절 매도"
    version = "1.0.0"

    default_params = {
        "tp_pct": 0.033,
        "min_trade_usdt": 6.0,
        "base_price_update_mode": "always",  # "always" | "if_higher"
    }

    tunable_params = {
        "tp_pct": {
            "type": "float", "min": 0.01, "max": 0.1, "step": 0.001,
            "title": "익절 비율", "unit": "%",
        },
    }

    async def tick(self, ctx, state, exchange, account_state, repos, open_lots):
        """open_lots 각각에 대해 고정 비율 익절 처리"""
        if not open_lots:
            return

        tp_pct = ctx.params.get("tp_pct", 0.033)
        min_trade_usdt = ctx.params.get("min_trade_usdt", 6.0)
        base_mode = ctx.params.get("base_price_update_mode", "always")
        filters = await exchange.get_symbol_filters(ctx.symbol)

        for lot in open_lots:
            target_price = lot.buy_price * (1 + tp_pct)
            target_price = await exchange.adjust_price(target_price, ctx.symbol)
            sell_qty = await exchange.adjust_qty(lot.buy_qty, ctx.symbol)
            notional = sell_qty * target_price

            if notional < filters.min_notional or notional < min_trade_usdt:
                continue

            if lot.sell_order_id:
                # 기존 주문 상태 체크 (FILLED/CANCELED/NEW)
                # FILLED 시:
                #   - core_bucket_usdt에 net_profit 적립
                #   - base_price 갱신 (base_mode에 따라)
                #   - lot close
                ...
            else:
                # 새 TP 주문 배치
                ...
```

**핵심 통합 포인트:**
- lot_stacking `_maybe_take_profit` (라인 331-453)와 trend_buy `_maybe_take_profit_trends` (라인 233-357) 통합
- 차이점은 `base_price_update_mode` 파라미터로 처리
- `client_oid` prefix: 기존 `_TP_`와 `_TTP_` 차이 -> combo_id 기반 prefix로 통일되므로 구분 불필요

### 5-4. account_trader.py 변경

```python
# account_trader.py step() -- 변경된 부분

class AccountTrader:
    def __init__(self, ...):
        ...
        # combo_id 기반 캐시 (같은 buy logic을 사용하는 여러 combo가 독립 인스턴스를 가짐)
        # 이유: _cooldown_ok()/_touch_order()가 인스턴스 변수(_last_order_ts)를 사용하므로,
        #       logic name 기반 캐시 시 combo 간 cooldown이 간섭됨
        self._buy_instances: dict[UUID, BaseBuyLogic] = {}   # key: combo_id
        self._sell_instances: dict[UUID, BaseSellLogic] = {}  # key: combo_id
        # self._strategy_instances 기존 유지 (Phase 5에서 제거)

    def _get_or_create_buy(self, combo_id: UUID, name: str) -> BaseBuyLogic:
        if combo_id not in self._buy_instances:
            self._buy_instances[combo_id] = BuyLogicRegistry.create_instance(name)
        return self._buy_instances[combo_id]

    def _get_or_create_sell(self, combo_id: UUID, name: str) -> BaseSellLogic:
        if combo_id not in self._sell_instances:
            self._sell_instances[combo_id] = SellLogicRegistry.create_instance(name)
        return self._sell_instances[combo_id]

    async def step(self):
        async with TradingSessionLocal() as session:
            ...
            # 변경: trading_combos 로드
            from app.models.trading_combo import TradingCombo
            stmt = select(TradingCombo).where(
                TradingCombo.account_id == self.account_id,
                TradingCombo.is_enabled == True,
            )
            result = await session.execute(stmt)
            combos = list(result.scalars().all())

            for combo in combos:
                buy_logic = self._get_or_create_buy(combo.id, combo.buy_logic_name)
                sell_logic = self._get_or_create_sell(combo.id, combo.sell_logic_name)

                combo_state = StrategyStateStore(self.account_id, str(combo.id), session)
                account_state = AccountStateManager(self.account_id, session)
                prefix = f"CMT_{str(self.account_id)[:8]}_{str(combo.id)[:8]}_"

                # 매수 파라미터 준비 (reference_combo_id 주입 포함)
                buy_params = buy_logic.validate_params(combo.buy_params or {})
                if combo.reference_combo_id:
                    buy_params["_reference_combo_id"] = str(combo.reference_combo_id)

                buy_ctx = StrategyContext(
                    account_id=self.account_id,
                    symbol=account.symbol,
                    base_asset=account.base_asset,
                    quote_asset=account.quote_asset,
                    current_price=cur_price,
                    params=buy_params,
                    client_order_prefix=prefix,
                )

                # 0. pre_tick: recenter (base_price 순서 보호 — 매도 이전에 실행)
                await buy_logic.pre_tick(buy_ctx, combo_state, self._client, repos, combo.id)

                # 1. 매도 (기존 로트 관리, TP 체결 시 base_price 갱신)
                sell_ctx = StrategyContext(
                    account_id=self.account_id,
                    symbol=account.symbol,
                    base_asset=account.base_asset,
                    quote_asset=account.quote_asset,
                    current_price=cur_price,
                    params=sell_logic.validate_params(combo.sell_params or {}),
                    client_order_prefix=prefix,
                )
                open_lots = await lot_repo.get_open_lots_by_combo(
                    self.account_id, account.symbol, combo.id,
                )
                await sell_logic.tick(sell_ctx, combo_state, self._client, account_state, repos, open_lots)

                # 2. 매수 (pending 처리 + 신규 매수, recenter 제외)
                await buy_logic.tick(buy_ctx, combo_state, self._client, account_state, repos, combo.id)
```

### 5-5. lot_repo 변경

```python
# app/db/lot_repo.py -- 추가/수정

async def get_open_lots_by_combo(
    self, account_id: UUID, symbol: str, combo_id: UUID
) -> list[Lot]:
    """특정 조합의 미결 로트 조회"""
    stmt = select(Lot).where(
        Lot.account_id == account_id,
        Lot.symbol == symbol,
        Lot.combo_id == combo_id,
        Lot.status == "OPEN",
    ).order_by(Lot.buy_time_ms.asc())
    result = await self._session.execute(stmt)
    return list(result.scalars().all())

async def insert_lot(
    self,
    *,
    account_id: UUID,
    symbol: str,
    strategy_name: str,
    buy_order_id: int | None,
    buy_price: float,
    buy_qty: float,
    buy_time_ms: int,
    combo_id: UUID | None = None,  # 신규 파라미터
) -> Lot:
    lot = Lot(
        account_id=account_id,
        symbol=symbol,
        strategy_name=strategy_name,
        buy_order_id=buy_order_id,
        buy_price=buy_price,
        buy_qty=buy_qty,
        buy_time_ms=buy_time_ms,
        combo_id=combo_id,  # 신규
        status="OPEN",
    )
    self._session.add(lot)
    await self._session.flush()
    return lot
```

---

## 6. 대시보드 변경

### 6-1. 조합 목록 뷰 (account_detail.html)

기존 "Tune Controls" 섹션(라인 64-149)을 "매매 조합" 섹션으로 교체:

```
+--------------------------------------------------------------+
|  매매 조합 (Trading Combos)                     [+ 새 조합]    |
|                                                               |
|  +---------------------------------------------------------+ |
|  | BTC 적립매수 고정익절                         [ON] [설정]  | |
|  | 매수: LOT 적립 매수 | 매도: 고정 비율 익절                | |
|  | buy_usdt=100 drop_pct=0.6% | tp_pct=3.3%                | |
|  +---------------------------------------------------------+ |
|                                                               |
|  +---------------------------------------------------------+ |
|  | BTC 추세매수 고정익절                         [ON] [설정]  | |
|  | 매수: 추세 매수 | 매도: 고정 비율 익절                    | |
|  | buy_usdt=50 enable_pct=3% | tp_pct=3.0%                 | |
|  +---------------------------------------------------------+ |
+--------------------------------------------------------------+
```

### 6-2. 기존 하드코딩 제거 대상

account_detail.html에서 제거할 하드코딩:
- 라인 39-40: `data-filter="lot_stacking"`, `data-filter="trend_buy"` 버튼 -> 조합별 동적 생성
- 라인 64-149: Tune Controls 전체 섹션 -> 조합 카드 UI로 교체
- JS: `loadTuneValues()`, `saveTuneValues()` 함수 -> combo CRUD API 호출로 교체

### 6-3. API 변경

**신규 API (조합 CRUD):**

```
GET    /api/accounts/{id}/combos              -> 조합 목록
POST   /api/accounts/{id}/combos              -> 조합 생성
PUT    /api/accounts/{id}/combos/{combo_id}   -> 조합 수정
DELETE /api/accounts/{id}/combos/{combo_id}   -> 조합 삭제 (OPEN 로트 가드)
POST   /api/accounts/{id}/combos/{combo_id}/enable   -> 활성화
POST   /api/accounts/{id}/combos/{combo_id}/disable  -> 비활성화

GET    /api/buy-logics                        -> 등록된 매수 로직 목록
GET    /api/sell-logics                       -> 등록된 매도 로직 목록
```

**변경 API:**

| 기존 API | 변경 내용 |
|----------|-----------|
| `GET /api/strategies` | 유지 (하위호환) + `GET /api/buy-logics`, `GET /api/sell-logics` 추가 |
| `GET /api/accounts/{id}/strategies` | deprecated -> `GET /api/accounts/{id}/combos` |
| `PUT /api/accounts/{id}/strategies/{name}` | deprecated -> `PUT /api/accounts/{id}/combos/{id}` |
| `GET /api/dashboard/{id}/lots` | `strategy` 쿼리 파라미터 -> `combo_id` 쿼리 파라미터 |
| `GET /api/dashboard/{id}/tune` | deprecated -> combo API로 대체 |
| `POST /api/dashboard/{id}/tune` | deprecated -> combo API로 대체 |
| `GET /api/dashboard/{id}` | `open_lots_count` 계산을 combo 기반으로 변경 |

**`app/api/dashboard.py` 변경 포인트:**
- 라인 44-45: `get_open_lots(... "lot_stacking")`, `get_open_lots(... "trend_buy")` 하드코딩 제거
  -> 모든 활성 combo의 OPEN lot count 합산
- 라인 82-91: `get_lots` 엔드포인트의 `strategy` 파라미터 -> `combo_id` 선택적 파라미터

### 6-4. 로트 필터링 변경

기존: 전략별 필터 ("LOT Stacking", "TREND Buy") -- 하드코딩된 2개 탭
변경: 조합별 필터 (조합 이름으로 동적 생성)

```html
<div class="filter-tabs" id="lot-filter-tabs">
  <button class="filter-tab active" data-filter="all">All</button>
  <!-- 서버에서 combo 목록 로드 후 동적 생성 -->
</div>
```

### 6-5. 스키마 변경

```python
# app/schemas/strategy.py -- 추가

class BuyLogicInfo(BaseModel):
    name: str
    display_name: str
    description: str
    version: str
    default_params: dict[str, Any]
    tunable_params: dict[str, dict[str, Any]]

class SellLogicInfo(BaseModel):
    name: str
    display_name: str
    description: str
    version: str
    default_params: dict[str, Any]
    tunable_params: dict[str, dict[str, Any]]

class ComboCreate(BaseModel):
    name: str
    buy_logic_name: str
    buy_params: dict[str, Any] = {}
    sell_logic_name: str
    sell_params: dict[str, Any] = {}
    reference_combo_id: UUID | None = None

class ComboResponse(BaseModel):
    id: UUID
    name: str
    buy_logic_name: str
    buy_params: dict[str, Any]
    sell_logic_name: str
    sell_params: dict[str, Any]
    reference_combo_id: UUID | None
    is_enabled: bool
    model_config = {"from_attributes": True}

class ComboUpdate(BaseModel):
    """조합의 파라미터와 이름만 변경 가능.
    buy_logic_name, sell_logic_name은 변경 불가 — 로직 타입 변경 시 기존 OPEN 로트가
    새 로직과 호환되지 않을 수 있으므로, 기존 조합을 비활성화하고 새 조합을 생성해야 한다."""
    name: str | None = None
    buy_params: dict[str, Any] | None = None
    sell_params: dict[str, Any] | None = None
    reference_combo_id: UUID | None = None


# app/schemas/trade.py -- 변경
class LotResponse(BaseModel):
    lot_id: int
    account_id: UUID
    symbol: str
    strategy_name: str
    combo_id: UUID | None = None  # 신규
    buy_price: float
    ...
```

---

## 7. Cross-combo 참조: trend_buy -> lot_stacking base_price

### 현재 문제

```python
# trend_buy.py:375 -- 현재 코드
lot_state = StrategyStateStore(ctx.account_id, "lot_stacking", state._session)
lot_base_price = await lot_state.get_float("base_price", 0.0)
```

`trend_buy`가 `lot_stacking`이라는 고정 scope 문자열로 다른 전략의 state에 직접 접근한다.
combo 모델에서는 scope가 `combo_id`(UUID)이므로, "어떤 조합의 base_price를 참조할 것인가?"를 알 수 없다.

### 해결: `reference_combo_id` 필드

`TradingCombo.reference_combo_id`에 참조 대상 조합의 ID를 저장한다.

**TrendBuy 매수 로직에서의 사용:**

```python
# buys/trend.py -- _maybe_buy_on_trend 변경
async def _maybe_buy_on_trend(self, ctx, state, exchange, account_state, repos, combo_id):
    ...
    # reference_combo_id는 combo 객체에서 가져와 ctx.params에 포함
    ref_combo_id = ctx.params.get("_reference_combo_id")
    if not ref_combo_id:
        # 참조 조합이 설정되지 않은 경우 독자적으로 동작 불가 -> skip
        logger.warning("trend_buy: no reference_combo_id configured, skipping")
        return

    ref_state = StrategyStateStore(ctx.account_id, str(ref_combo_id), state._session)
    lot_base_price = await ref_state.get_float("base_price", 0.0)
    if lot_base_price <= 0:
        return
    ...
```

**account_trader.py에서 주입:**

```python
# account_trader.py -- combo 루프 내부
buy_params = buy_logic.validate_params(combo.buy_params or {})
if combo.reference_combo_id:
    buy_params["_reference_combo_id"] = str(combo.reference_combo_id)
```

**마이그레이션 시:**
- 동일 계정에 lot_stacking combo와 trend_buy combo가 둘 다 있으면, trend_buy combo의 `reference_combo_id`를 lot_stacking combo의 ID로 설정.
- 동일 계정에 lot_stacking이 없으면 `reference_combo_id = NULL` (추세 매수가 독자 동작)

**대시보드 UI:**
- 조합 생성/편집 시 "참조 조합" 드롭다운 표시 (해당 계정의 다른 조합 목록)
- trend_buy 로직 선택 시에만 표시 (다른 매수 로직은 참조 불필요)

---

## 8. 마이그레이션 경로

### 8-1. Alembic 마이그레이션 스크립트

```python
# alembic/versions/003_trading_combos.py

def upgrade():
    # 1. trading_combos 테이블 생성
    op.create_table("trading_combos", ...)

    # 2. lots에 combo_id 컬럼 추가 (nullable)
    op.add_column("lots", sa.Column("combo_id", UUID, nullable=True))
    op.create_foreign_key("fk_lots_combo", "lots", "trading_combos", ["combo_id"], ["id"])
    op.create_index("idx_lots_combo", "lots", ["account_id", "combo_id", "status"])

    # 3. 데이터 마이그레이션 (Python 블록)
    conn = op.get_bind()

    # 3a. strategy_configs -> trading_combos 변환
    strategy_configs = conn.execute(text("SELECT * FROM strategy_configs"))
    combo_mapping = {}  # (account_id, strategy_name) -> combo_id

    for sc in strategy_configs:
        combo_id = uuid4()
        params = sc.params or {}

        if sc.strategy_name == "lot_stacking":
            buy_params = {k: params[k] for k in [
                "buy_usdt", "drop_pct", "prebuy_pct", "cancel_rebound_pct",
                "min_trade_usdt", "recenter_enabled", "recenter_pct",
                "recenter_ema_n", "use_fixed_usdt_reference",
            ] if k in params}
            sell_params = {
                "tp_pct": params.get("tp_pct", 0.033),
                "min_trade_usdt": params.get("min_trade_usdt", 6.0),
                "base_price_update_mode": "always",
            }
            name = "LOT 적립 매수 고정익절"

        elif sc.strategy_name == "trend_buy":
            buy_params = {k: params[k] for k in [
                "buy_usdt", "enable_pct", "recenter_pct", "drop_pct",
                "step_pct", "min_trade_usdt",
            ] if k in params}
            sell_params = {
                "tp_pct": params.get("tp_pct", 0.03),
                "min_trade_usdt": params.get("min_trade_usdt", 6.0),
                "base_price_update_mode": "if_higher",
            }
            name = "추세 매수 고정익절"
        else:
            continue

        conn.execute(text("""
            INSERT INTO trading_combos (id, account_id, name, buy_logic_name,
                buy_params, sell_logic_name, sell_params, is_enabled, created_at, updated_at)
            VALUES (:id, :account_id, :name, :buy_logic_name,
                :buy_params, 'fixed_tp', :sell_params, :is_enabled, now(), now())
        """), {
            "id": combo_id, "account_id": sc.account_id,
            "name": name, "buy_logic_name": sc.strategy_name,
            "buy_params": json.dumps(buy_params),
            "sell_params": json.dumps(sell_params),
            "is_enabled": sc.is_enabled,
        })
        combo_mapping[(str(sc.account_id), sc.strategy_name)] = combo_id

    # 3b. trend_buy combo에 reference_combo_id 설정
    for (acct_id, sname), combo_id in combo_mapping.items():
        if sname == "trend_buy":
            ref_id = combo_mapping.get((acct_id, "lot_stacking"))
            if ref_id:
                conn.execute(text("""
                    UPDATE trading_combos SET reference_combo_id = :ref_id WHERE id = :combo_id
                """), {"ref_id": ref_id, "combo_id": combo_id})

    # 3c. lots의 combo_id 매핑
    for (acct_id, sname), combo_id in combo_mapping.items():
        conn.execute(text("""
            UPDATE lots SET combo_id = :combo_id
            WHERE account_id = :acct_id AND strategy_name = :sname
        """), {"combo_id": combo_id, "acct_id": acct_id, "sname": sname})

    # 3d. strategy_state scope 매핑
    for (acct_id, sname), combo_id in combo_mapping.items():
        conn.execute(text("""
            UPDATE strategy_state SET scope = :new_scope
            WHERE account_id = :acct_id AND scope = :old_scope
        """), {"new_scope": str(combo_id), "acct_id": acct_id, "old_scope": sname})

    # 3e. state 키 이름 통일 (pending_core_bucket_usdt, pending_trend_bucket_usdt -> pending_bucket_usdt)
    conn.execute(text("""
        UPDATE strategy_state SET key = 'pending_bucket_usdt'
        WHERE key IN ('pending_core_bucket_usdt', 'pending_trend_bucket_usdt')
    """))

    # 3f. pending_kind 키 보존 확인 (lot_stacking 전용, INIT/LOT 구분)
    # pending_kind는 키 이름 변경 불필요 — scope만 변경되면 됨 (3d에서 처리 완료)
    # 마이그레이션 시점에 pending_kind에 값이 있는 경우, scope 변환 후에도 동일한 키로 유지
    # 주의: pending 주문이 있는 상태에서 마이그레이션 시 pending_kind 값 손실 시
    #       INIT/LOT 구분 불가 → reserve 적립 오류 가능. 섹션 8-3의 안전 절차 참조.


def downgrade():
    # 주의: Alembic downgrade는 strategy_state.scope의 UUID→전략명 역매핑을 지원하지 않음.
    # 프로덕션 롤백은 반드시 pg_dump 복원으로 수행할 것 (섹션 8-4 참조).
    conn = op.get_bind()

    # lots.combo_id NULL 처리 (역매핑 불가하므로 단순 제거)
    op.drop_index("idx_lots_combo")
    op.drop_constraint("fk_lots_combo", "lots")
    op.drop_column("lots", "combo_id")
    op.drop_table("trading_combos")
```

### 8-2. 파라미터 분리 매핑 (상세)

```
lot_stacking params -> buy_params + sell_params:
  buy_params:  buy_usdt, drop_pct, prebuy_pct, cancel_rebound_pct,
               min_trade_usdt, recenter_enabled, recenter_pct,
               recenter_ema_n, use_fixed_usdt_reference
  sell_params: tp_pct, min_trade_usdt, base_price_update_mode="always"

trend_buy params -> buy_params + sell_params:
  buy_params:  buy_usdt, enable_pct, recenter_pct, drop_pct, step_pct, min_trade_usdt
  sell_params: tp_pct, min_trade_usdt, base_price_update_mode="if_higher"
```

**주의: `min_trade_usdt`는 매수와 매도 양쪽에서 사용된다. 양쪽 params에 모두 복사.**

### 8-3. 실행 중인 주문 처리 (주의)

마이그레이션 시점에 `pending_order_id`가 있는(미체결 매수 주문 존재) state가 있을 수 있다.

**안전 절차:**
1. 마이그레이션 전 트레이딩 엔진 정지 (all AccountTrader.stop())
2. 미체결 주문이 있는 계정 식별:
   ```sql
   SELECT account_id, scope, key, value FROM strategy_state
   WHERE key = 'pending_order_id' AND value != '' AND value IS NOT NULL;
   ```
3. **pending_kind 값 확인** (lot_stacking 전용, INIT/LOT 구분):
   ```sql
   SELECT account_id, scope, key, value FROM strategy_state
   WHERE key = 'pending_kind' AND value != '' AND value IS NOT NULL;
   ```
   - `pending_kind = 'INIT'`: 최초 reserve 매수 주문 — 체결 시 reserve 설정 로직 실행
   - `pending_kind = 'LOT'`: 일반 로트 매수 주문 — 체결 시 로트 생성 로직 실행
   - **INIT 상태의 pending 주문이 있으면 마이그레이션 전에 반드시 체결을 기다리거나 취소할 것**
     (INIT 처리는 lot_stacking 매수 로직에서만 구현되므로, scope 변환 후에도 정상 동작하지만
      pending_kind 값이 유실되면 reserve 적립 대신 일반 LOT으로 처리되어 자금 배분 오류 발생)
4. 해당 주문을 거래소에서 취소하거나, state의 pending 키들이 마이그레이션에서 올바르게 이전되었는지 확인
   - 확인 항목: `pending_order_id`, `pending_time_ms`, `pending_bucket_usdt`(키 변환 후), `pending_kind`, `pending_trigger_price`
5. 마이그레이션 실행
6. `client_order_prefix` 변경으로 기존 미체결 주문의 client_oid가 새 형식과 불일치하지만, 주문 추적은 `pending_order_id`(거래소 orderId)로 하므로 문제없음

### 8-4. 롤백 계획

**주 롤백 수단: pg_dump 복원** (Alembic downgrade는 보조 수단)

`strategy_state.scope`가 전략명 → UUID로 비가역 변환되므로, Alembic downgrade만으로는 완전한 롤백이 불가능하다.
프로덕션 롤백은 반드시 pg_dump 백업 복원으로 수행한다.

1. 마이그레이션 전 전체 DB 백업 (`pg_dump --format=custom -f backup_pre_combo.dump`)
2. Alembic `downgrade()`: 테이블/컬럼 구조만 복원 (strategy_state scope 역매핑은 미지원)
3. 프로덕션 롤백 절차: `pg_restore` → 기존 코드 배포 → 엔진 재시작
4. 기존 strategy_configs는 Phase 5까지 삭제하지 않으므로, 코드만 롤백하면 즉시 기존 동작 복원 가능
5. account_trader.py의 기존 코드도 Phase 5까지 유지 (주석 또는 분기)

---

## 9. 백테스트 러너 호환성

### 현재 백테스트 구조

`backtest/isolated_runner.py`는 `StrategyRegistry`를 통해 전략 인스턴스를 생성하고, 기존 `BaseStrategy.tick()` 인터페이스로 실행한다.

```python
# 현재 코드 (isolated_runner.py:87-89)
strategies[name] = StrategyRegistry.create_instance(name)
...
await strategy.tick(ctx, state, client, shared, repos)
```

### 전환 방안

**Phase 3에서:** 기존 `StrategyRegistry`와 `BaseStrategy` 유지. 백테스트는 레거시 전략 클래스를 계속 사용.

**Phase 5에서:** 백테스트도 combo 기반으로 전환.

```python
# 변경 후 백테스트 실행
for combo_config in backtest_combos:
    buy_logic = BuyLogicRegistry.create_instance(combo_config["buy_logic_name"])
    sell_logic = SellLogicRegistry.create_instance(combo_config["sell_logic_name"])

    state = StrategyStateStore(account_id, str(combo_id), session)

    # 매도 먼저
    open_lots = await lot_repo.get_open_lots_by_combo(account_id, symbol, combo_id)
    await sell_logic.tick(sell_ctx, state, client, shared, repos, open_lots)

    # 매수
    await buy_logic.tick(buy_ctx, state, client, shared, repos, combo_id)
```

**BacktestRun 모델 변경:**
- `strategies: list[str]` -> `combos: list[dict]` (각 dict에 buy_logic_name, sell_logic_name, params)
- 하위호환: 기존 `strategies` 필드가 있으면 자동으로 combo 형태로 변환

---

## 10. 구현 Phase

### Phase 1 -- 기반 인프라 (1일)

> 위험도: **낮음** (기존 동작 변경 없음)

**작업 항목:**

| # | 작업 | 파일 | 수락 기준 |
|---|------|------|-----------|
| 1-1 | `BaseBuyLogic`, `BaseSellLogic` 기본 클래스 작성 | `app/strategies/base.py` | 클래스 정의 존재, `_cooldown_ok`/`_touch_order` 포함 |
| 1-2 | `BuyLogicRegistry`, `SellLogicRegistry` 작성 | `app/strategies/registry.py` | register/get/create_instance/list_all 동작 |
| 1-3 | 공통 헬퍼 모듈 | `app/strategies/utils.py` (신규) | `extract_base_commission_qty`, `extract_fee_usdt` 함수 |
| 1-4 | `TradingCombo` SQLAlchemy 모델 | `app/models/trading_combo.py` (신규) | reference_combo_id 포함 |
| 1-5 | `app/models/__init__.py` 등록 | `app/models/__init__.py` | TradingCombo import/export |
| 1-6 | `TradingAccount` relationship 추가 | `app/models/account.py` | `trading_combos` relationship |
| 1-7 | Alembic 마이그레이션 (테이블 생성만) | `alembic/versions/003_trading_combos.py` | `trading_combos` 테이블, `lots.combo_id` 컬럼 |
| 1-8 | `lot_repo.get_open_lots_by_combo()` 추가 | `app/db/lot_repo.py` | 메서드 존재, combo_id로 필터링 |
| 1-9 | `lot_repo.insert_lot()` combo_id 파라미터 추가 | `app/db/lot_repo.py` | 기존 호출에 영향 없음 (default=None) |
| 1-10 | `buys/` 및 `sells/` 디렉토리 생성 | `app/strategies/buys/__init__.py`, `app/strategies/sells/__init__.py` | 빈 패키지 |

**검증**: 기존 테스트 전부 통과. 새 테이블이 존재하지만 아무도 사용하지 않음.

### Phase 2 -- 로직 분리 추출 (1.5일)

> 위험도: **중간** (핵심 매매 로직 이동)

**작업 항목:**

| # | 작업 | 파일 | 수락 기준 |
|---|------|------|-----------|
| 2-1 | `LotStackingBuy` 추출 | `app/strategies/buys/lot_stacking.py` (신규) | 매수 관련 메서드 전부 이동, utils import |
| 2-2 | `TrendBuy` 추출 | `app/strategies/buys/trend.py` (신규) | 매수 관련 메서드 전부 이동, reference_combo_id 기반 참조 |
| 2-3 | `FixedTpSell` 추출 | `app/strategies/sells/fixed_tp.py` (신규) | 두 전략의 TP 로직 통합, `base_price_update_mode` 파라미터 |
| 2-4 | pending state 키 이름 통일 | buys/*.py | `pending_bucket_usdt` 사용 |
| 2-5 | `__init__.py`에 auto-import 설정 | `buys/__init__.py`, `sells/__init__.py` | registry에 자동 등록 |
| 2-6 | 단위 테스트 | `tests/` | 각 로직 독립 tick() 테스트, state 읽기/쓰기 검증 |

**검증**:
- 새 로직 클래스의 tick()이 기존과 동일한 주문을 생성하는지 mock exchange로 검증
- 기존 `LotStackingStrategy`, `TrendBuyStrategy`는 **이 시점에서 아직 유지** (안전망)
- `FixedTpSell`에서 `base_price_update_mode="always"`와 `"if_higher"` 모두 테스트

### Phase 3 -- 실행 엔진 전환 + 데이터 마이그레이션 (1.5일)

> 위험도: **높음** (트레이딩 루프 변경 + 라이브 데이터 마이그레이션)

**작업 항목:**

| # | 작업 | 파일 | 수락 기준 |
|---|------|------|-----------|
| 3-1 | 데이터 마이그레이션 스크립트 완성 | `alembic/versions/003_...` | combo 생성, lots.combo_id 매핑, state scope 매핑, state 키 통일 |
| 3-2 | `account_trader.py` combo 기반 실행 전환 | `app/services/account_trader.py` | `trading_combos` 로드, buy/sell 분리 실행 |
| 3-3 | `client_order_prefix` 형식 변경 | `account_trader.py` | `CMT_{account[:8]}_{combo[:8]}_` 형식 |
| 3-4 | 스키마 변경 (ComboCreate, ComboResponse 등) | `app/schemas/strategy.py` | Pydantic 모델 작동 |
| 3-5 | LotResponse에 combo_id 추가 | `app/schemas/trade.py` | 기존 lot도 combo_id=None으로 호환 |
| 3-6 | 통합 테스트 | `tests/` | 마이그레이션 후 동일 매매 동작 확인 |

**마이그레이션 실행 절차:**
1. 트레이딩 엔진 정지
2. DB 백업 (`pg_dump`)
3. 미체결 주문 확인/처리
4. `alembic upgrade head` 실행
5. 마이그레이션 결과 검증 (combo 개수, lot combo_id 매핑, state scope 확인)
6. 새 코드 배포
7. 트레이딩 엔진 재시작

### Phase 4 -- 대시보드 UI + API (1.5~2일)

> 위험도: **중간** (프론트엔드 전면 변경)

**작업 항목:**

| # | 작업 | 파일 | 수락 기준 |
|---|------|------|-----------|
| 4-1 | 조합 CRUD API | `app/api/combos.py` (신규) 또는 `app/api/strategies.py` 확장 | CRUD + enable/disable 동작 |
| 4-2 | buy-logics / sell-logics 카탈로그 API | `app/api/strategies.py` 확장 | 등록된 로직 목록 반환 |
| 4-3 | `app/api/dashboard.py` 하드코딩 제거 | `app/api/dashboard.py` | 라인 44-45 전략명 하드코딩 제거 |
| 4-4 | 조합 목록/생성/편집 UI | `account_detail.html` | Tune Controls 섹션 교체 |
| 4-5 | 로트 필터링 동적화 | `account_detail.html` | 조합별 탭 동적 생성 |
| 4-6 | admin.html 전략 배정 UI (선택) | `admin.html` | 조합 관리 가능 |
| 4-7 | 기존 tune API deprecated 처리 | `app/api/dashboard.py` | 기존 엔드포인트 유지하되 combo API로 리다이렉트 |

### Phase 5 -- 정리 + 안전장치 + 백테스트 (1일)

> 위험도: **낮음~중간**

**작업 항목:**

| # | 작업 | 파일 | 수락 기준 |
|---|------|------|-----------|
| 5-1 | 기존 전략 파일 제거 | `app/strategies/lot_stacking.py`, `trend_buy.py` | 파일 삭제, import 에러 없음 |
| 5-2 | `StrategyRegistry` 레거시 코드 정리 | `app/strategies/registry.py` | BaseStrategy 관련 코드 deprecated 표시 또는 제거 |
| 5-3 | `strategy_configs` 관련 코드 정리 | 다수 | 기존 strategy API deprecated |
| 5-4 | 조합 삭제 시 OPEN 로트 가드 | combo CRUD API | OPEN lot이 있으면 삭제 거부 + 에러 메시지 |
| 5-5 | 조합 삭제 시 state 클린업 | combo CRUD API | strategy_state에서 해당 scope 삭제 |
| 5-6 | 백테스트 러너 combo 기반 전환 | `backtest/isolated_runner.py` | combo 설정으로 백테스트 실행 가능 |
| 5-7 | BacktestRun 모델/API 조합 지원 | `app/models/backtest_run.py`, `app/api/backtest.py` | 하위호환 유지 |

---

## 11. 리스크 및 대응

### HIGH

| 리스크 | 영향 | 대응 |
|--------|------|------|
| **매매 로직 이동 중 미묘한 동작 변경** | 잘못된 주문 발생, 손실 가능 | Phase 2에서 mock exchange 기반 단위 테스트로 기존과 동일한 주문 생성 검증 |
| **데이터 마이그레이션 실패** | state/lot의 combo_id 매핑 오류 시 매매 중단 | 마이그레이션 전 DB 백업, 롤백 스크립트 준비, 엔진 정지 상태에서 실행 |
| **실행 중인 pending 주문과 마이그레이션 충돌** | 주문 추적 실패 | 마이그레이션 전 pending 주문 식별/취소, 엔진 정지 상태 확인 |

### MEDIUM

| 리스크 | 영향 | 대응 |
|--------|------|------|
| **trend_buy cross-combo 참조 실패** | 추세 매수 비활성화 | `reference_combo_id` NULL 시 graceful skip + 경고 로그 |
| **client_order_prefix 변경** | 기존 미체결 주문과 prefix 불일치 | 주문 추적은 orderId 기반이므로 영향 없음 (client_oid는 배치 시에만 사용) |
| **백테스트 러너 미전환** | Phase 5까지 기존 StrategyRegistry 사용 | 레거시 코드 유지하여 백테스트 동작 보장 |

### LOW

| 리스크 | 영향 | 대응 |
|--------|------|------|
| **대시보드 UI 변경 범위** | 개발 시간 초과 | 조합 목록/생성만 1차 구현, 고급 기능(프리셋, 복제)은 후속 |
| **`min_trade_usdt` 양쪽 중복** | 사용자 혼동 | 대시보드에서 명확히 "매수 최소금액" vs "매도 최소금액" 표시 |

---

## 12. 기존 계획과의 관계

### 03.STRATEGY_CUSTOMIZATION_PLAN.md (전략 커스터마이징)

- `is_public` 개념: 매수 로직과 매도 로직 각각에 적용 가능
- 대시보드 동적화: 조합 UI로 대체
- Admin 전략 배정: 조합 단위로 배정하거나 매수/매도 로직 가시성 제어
- **이 계획이 03 계획을 대부분 supersede함**

### 04.ACCOUNT_PLAN.md (인증 전환)

- 독립적. 인증 전환과 매수/매도 분리는 서로 영향 없음
- 다만 동시 진행 시 충돌 파일: `admin.html`, `main.js`, `account_detail.html`

---

## 13. 총 예상 공수

| Phase | 내용 | 공수 | 위험도 |
|-------|------|------|--------|
| Phase 1 | 기반 인프라 (기본 클래스, DB, 레지스트리) | 1일 | 낮음 |
| Phase 2 | 로직 분리 추출 + 단위 테스트 | 1.5일 | 중간 |
| Phase 3 | 실행 엔진 전환 + 데이터 마이그레이션 | 1.5일 | **높음** |
| Phase 4 | 대시보드 UI + API | 1.5~2일 | 중간 |
| Phase 5 | 정리 + 안전장치 + 백테스트 전환 | 1일 | 낮음~중간 |
| **합계** | | **6.5~7일** | |

---

## 부록 A: 변경 파일 전체 목록

```
수정:
  app/strategies/base.py              -- BaseBuyLogic, BaseSellLogic 추가
  app/strategies/registry.py          -- BuyLogicRegistry, SellLogicRegistry 추가
  app/services/account_trader.py      -- combo 기반 실행 루프
  app/models/__init__.py              -- TradingCombo 등록
  app/models/account.py               -- trading_combos relationship
  app/models/lot.py                   -- combo_id 컬럼
  app/db/lot_repo.py                  -- get_open_lots_by_combo, insert_lot combo_id
  app/api/dashboard.py                -- 하드코딩 전략명 제거, combo 기반
  app/api/strategies.py               -- combo CRUD, buy/sell 카탈로그
  app/schemas/strategy.py             -- ComboCreate, ComboResponse 등
  app/schemas/dashboard.py            -- TuneUpdate deprecated
  app/schemas/trade.py                -- LotResponse combo_id
  app/dashboard/templates/account_detail.html  -- combo UI
  app/dashboard/static/js/main.js     -- combo 관련 JS
  backtest/isolated_runner.py         -- combo 기반 실행 (Phase 5)

신규:
  app/strategies/utils.py             -- 공통 헬퍼
  app/strategies/buys/__init__.py
  app/strategies/buys/lot_stacking.py -- LotStackingBuy
  app/strategies/buys/trend.py        -- TrendBuy
  app/strategies/sells/__init__.py
  app/strategies/sells/fixed_tp.py    -- FixedTpSell
  app/models/trading_combo.py         -- TradingCombo 모델
  alembic/versions/003_trading_combos.py

삭제 (Phase 5):
  app/strategies/lot_stacking.py      -- 기존 전략 (레거시)
  app/strategies/trend_buy.py         -- 기존 전략 (레거시)
```
